---
layout: post
title: "[Python] class part-1: 절차 지향 프로그램과 객체 지향 프로그램"
date: "2018-10-08"
excerpt: "객체 지향 언어의 특징"
output: github_document
tag:
    [python, class, procedural, POLs, OOLs]
comments: true
categories:
  Python
---

## 절차(구조적) 지향 프로그램(procedural language)

- 대표적인 언어는 C 언어이다.
- 물이 위에서 아래로 흐르는 것처럼 순차적으로 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법
- 단점
        - 재사용할 수 없다.
        - 확장성이 떨어진다.
        - 유지보수가 어렵다.

<br>

예제를 통해 알아보자.

```
A와 B가 사용하는 프로그램을 만들려고 한다. 다음과 같이 결과는 7이 출력되도록 함수를 만드세요.

adder(3)
adder(4)
```

<br>

```{python}
x = 0
def adder(arg):
    global x    
    x += arg
    return x

# A
print(adder(3))
print(adder(4))

# B
print(adder(5))
print(adder(5))
```

 위 프로그램을 A란 사람이 사용하고 뒤이어 B가 사용한다고 가정하자. B가 저 메소드를 사용하면 7값이 저장되어 있어서, 누적된 값에 더해질 수 밖에 없다. 그래서 저 메소드를 A와 B가 모두 사용하려면 다음과 같이 서로 다른 이름으로 메소드를 선언하고 사용하여야 한다. 

```{python}
x1 = 0
def adder1(arg):
    global x    
    x += arg
    return x
x2 = 0
def adder2(arg):
    global x    
    x += arg
    return x

# A
print(adder1(3))
print(adder1(4))

# B
print(adder2(5))
print(adder2(5))
```

이 문제는 객체 지향 프로그램으로 해결할 수 있다. 하나의 프로그램을 둘이 따로따로 쓰는 것처럼 사용하는 것이 객체 지향 프로그램이다.


***

## 객체 지향 프로그램(object oriented language)

- java, c++, c#, python
- 구조적 프로그래밍과 다르게 큰 문제를 작게 쪼개는 것이 아니라 먼저 작은 문제들을 해결할 수 있는 객체들을 만든 뒤 이 객체들을 조합해서 큰 문제를 해결하는 방법
- `객체(Object)`: 사물 개념중에서 명사로 표현할 수 있는 것을 의미한다. 사람, 건물, 학생 등
- `클래스(Class)`: 객체를 설명해 놓은 것(객체의 설계도)
- `인스턴스(Instance)`: 클래스를 메모리에 만들어서 사용하도록 하는 의미

<br>

객체를 사람이라 생각하면 다음과 같다.

- 객체 = 사람
- 속성(attribute, field) = 변수: 팔, 다리, 머리, 눈, 코, 입, 나이, 주소, 학번, 성적, 성격 등 => 수치나 값으로 표현
- 메소드(method) = 함수: 기능의 프로그램 처리, 동작하는 것, 속성의 값을 변경하는 기능

<br>

그럼 위의 A와 B가 쓰는 프로그램을 객체 지향 프로그램으로 만들어 보자.

```{python}
class Calculator:
    def __init__(self): 
        # 초기화 
        # self는 자기 자신을 의미
        self.result = 0
        
    def adder(self,num):
        self.result += num
        return self.result
    
# A
cal1 = Calculator() # 인스턴스 생성. 클래스를 사용할 수 있도록 메모리를 구성
print(cal1.adder(3))
print(cal1.adder(4))

# B
cal2 = Calculator()
print(cal2.adder(5))
print(cal2.adder(5))
```
