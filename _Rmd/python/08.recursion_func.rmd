---
layout: post
title: "[Python] Recursion"
date: "2018-09-01"
excerpt: "자기 자신을 다시 호출하는 방법"
output: github_document
tag:
    [python, recursion]
comments: true
categories:
  Python
---

## 재귀호출

자기 자신을 다시 호출하는 것을 뜻한다. 함수 안에서 내 함수를 다시 호출하므로 `반복문 + stack 구조`가 필요하다. `stack`은 FILO(First In Last Out, 선입후출) 혹은 LIFO(Last In First Out, 후입선출)의 성격을 띈다.

<br>

- 참고 용어
`Push`: Push stack의 구조상 마지막 데이터 위치에 입력된다. 
`Pop`: 마지막 데이터 위치에서 데이터를 꺼내는 작업(삭제)

<br>

아래의 조건에 맞는 함수를 만들어보자.

```
stack을 리스트 타입로 만든다. 

push 함수는 stack변수에 값을 넣는다. 
pop 함수는 stack변수에 값을 삭제한다.
```

```{r, engine='python'}
stack = []
def push(x):
    global stack
    return stack.append(x)


def pop():
    global stack
    if len(stack) == 0:
        return None
    return stack.pop()


push(1)
print(stack)

push(2)
print(stack)

pop()
print(stack)
```

`Queue` 형태로 만들기 위해선 기존 값을 담을 수 있는 공간을 만들고 마지막 값을 차례대로 옮기고 마지막 것을 뽑으면 된다. (하노이탑 알고리즘)

***

### factorial 

factorial 함수를 만들면서 재귀호출 함수를 이해해보자. 우선 factorial이 어떻게 되어있는지 알아보자.

```
factorial 함수

n! = n * (n-1) * (n-2) * ... * 2 * 1
n! = n * (n-1)!
n! = n * (n-1) * (n-2)!
n! = n * (n-1) * (n-2) * ... * 2 * 1!
...
```

그렇다면, n의 조건에 따른 함수식은 다음과 같다.

```
factorial 공리
    n * factorial(n-1)  (n >= 1)
    factorial(n) = 1    (n = 0)
```

> 참고로 factorial 함수는 반복문으로도 만들 수 있다. 하지만 재귀함수를 사용해서 만드는 이유는 코드가 더 간단해지고 깔끔해 질 수 있기 때문이다. 재귀함수를 만들 때 성능이 더 떨어질 수 있고, 무한루프에 빠질 수 있으니 이를 주의해서 사용하도록 해야 한다.

<br>

그럼 위를 토대로 factorial 함수를 만들어보자

```{r, engine='python'}
# 반복문
def factorial(n):
    f = 1
    for i in range(n,0,-1):
        f *= i
    return f
    
print(factorial(5))
```

<br>

```{r, engine='python'}
# 재귀호출함수

def factorial(n):
    if n == 1 or n == 0:
        return 1
        
    return n*factorial(n-1)
    
print(factorial(5))
```

`factorial(5)`는 `5*factorial(4)`이므로 `factorial(4)`를 push한다. 이후에는 `factorial(3)`을 push하면서 push를 반복한다. 그리고 `factorial(1)`일 때 조건에 만족하니 `1`값을 return해주고 `factorial(1)`을 pop하고 이후에 `factorial(2)`를 pop하며 반복하여 마지막에는 상수값을 곱하여 최종값을 return해준다. 

***

### Greatest Common Divisor

최대공약수는 유클리드 알고리즘으로 구할 수 있다.

>유클리드 알고리즘 : 주어진 두 수 사이에 존재하는 최대공약수(GCD(Greatest Common Divisor))를 구하는 알고리즘

```
1. 두 수 m, n (m > n)를 입력으로 들어온다.
2. n이 0이면 m을 출력하고 알고리즘은 종료한다.
3. m이 n으로 나누어 떨어지면, n을 출력하고 알고리즘은 종료한다.
4. 그렇지 않으면, m을 n으로 나눈 나머지를 새롭게 m에 대입하고 m과 n을 바꾸고 3번으로 돌아간다.
```

<br>

위의 알고리즘대로 코드를 짜면 다음과 같다.

```{r, engine='python'}
def gcd(m,n):
    if m < n:
        m = n
        n = m
    
    if n == 0:
        return m
    elif m % n == 0:
        return n
    else:
        m = m % n
        return gcd(m,n)
        
print(18,12)
```    

더 간단하게 바꿀 수 있다.

```{python}
def gcd(x,y):
    if y == 0:
        return x
    return gcd(y,x%y)
  
print(18,12)
```

반복문으로 구현하면 다음과 같다.

```{r, engine='python'}
def gcd(x,y):
    if x < y:
        x,y = y,x # switching
    while(y != 0):
        n = x%y
        x = y
        y = n
    return x
    
print(18,12)
```
