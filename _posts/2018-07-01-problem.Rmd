---
layout: post
title: "SQL QUIZ"
date: "2017-07-01"
excerpt: "SQL problem"
tag:
  -sql
output: github_document
---

<br>

***

### 문제 1 -연결연산자,열 별칭

<br>
```
employees 테이블에서 employee_id, last_name과 first_name은 연결해서 표시하고(공백으로 구분) 열 별칭은 화면예 처럼 보고서 작성해 주세요.

화면예>
Emp# 	Employee Name
---------- ------------------------------
100 	King Steven
101 	Kochhar Neena
102 	De Haan Lex
103 	Hunold Alexander
104 	Ernst Bruce
```
<br>
```sql
SELECT 
employee_id "Emp#"", last_name || ' ' || first_name "Employee Name"
FROM employees;
```
<br>

***

### 문제 2
<br>
```
employees 테이블에서 컬럼중에 last_name, job_id를 연결해서 표시하고(쉼표와 공백으로 구분) 열 별칭은 화면예 처럼 보고서 작성하세요.


화면예>

Employee and Title
-------------------------
Abel, SA_REP
Ande, SA_REP
```
<br>
```sql
SELECT
last_name || ', ' || job_id "Employee and Title"
FROM employees;
```
<br>

***

### 문제 3
<br>
```
employees 테이블에서 급여가 2500 ~ 3500 인 사원들의 모든 정보를 조회하세요.
```
<br>
```sql
SELECT *
FROM employees
WHERE salary>=2500
AND salary<=3500;
```
```sql
SELECT *
FROM employees
WHERE salary between 2500 and 3500;
```
<br>

***

### 문제 4
<br>
```
관리자의 사원번호가 100,101,200인 사원들의 모든 정보를 출력해주세요.
```
<br>
```sql
SELECT *
FROM employees
WHERE manager_id = 100
OR manager_id = 101
OR manager_id = 200;
```
```sql
SELECT *
FROM employees
WHERE manager_id in (100,101,200);
```
<br>

***

### 문제 5 -LIKE 연산자

<br>
```
last_name 두번째 위치에 소문자 o가 있고 뒤에 어떤 글자가 올지 모른다. 이 조건에 해당하는 데이터를 추출해주세요.
```
<br>
```sql
SELECT *
FROM employees
WHERE last_name like '_o%';

/* LIKE연산자는 문자패턴을 찾는 연산자(다른 타입은 형 변환이 이루어짐)*/
```
<br>

***

### 문제 6 -연결연산자, 열 별칭, q연산자

<br>
```
departments 테이블에 있는 데이터에서 department_name , manager_id 컬럼을 가지고 화면 결과 처럼 출력하는 쿼리문장을 만드세요.



<화면 결과>

Department and Manager
--------------------------------------------------------------------------------
Administration Department's Manager Id: 200
Marketing Department's Manager Id: 201
Purchasing Department's Manager Id: 114
Human Resources Department's Manager Id: 203
Shipping Department's Manager Id: 121
IT Department's Manager Id: 103
Public Relations Department's Manager Id: 204
Sales Department's Manager Id: 145
Executive Department's Manager Id: 100
Finance Department's Manager Id: 108
Accounting Department's Manager Id: 205
......
```
<br>
```sql
SELECT *
FROM tab;

SELECT *
FROM departments;

SELECT department_name || q'[ Department's Manager Id: ]' || manager_id AS "Department and Manager"
FROM departments;
```
```sql
SELECT department_name || ' Department''s Manager Id: ' || manager_id AS "Department and Manager"
FROM departments;
```
<br>

***

### 문제 7 -조건절(WHERE)

<br>
``` 
employees 테이블에 있는 데이터 중에  last_name에 Whalen 이라는 사원의 모든 정보를 출력하세요.
```
<br>
```sql
SELECT *
FROM employees
WHERE last_name = 'Whalen';

/* 숫자 외엔 모두 ' ' 로 표현해야*/
```
<br>

***

### 문제 8
<br>
```
EMPLOYEES 테이블에서 급여가 3000보다 작거나 같은 사원의 last_name, salary 를 출력하세요.
```
<br>
```sql
SELECT last_name, salary
FROM employees
WHERE salary<=3000;
```
<br>

***

### 문제 9 -BETWEEN 연산자

<br>
```
EMPLOYEES 테이블에서 salary(급여)값이 10000이상부터 15000이하인 사원들의 모든정보를 출력하세요.
```
<br>
```sql
SELECT *
FROM employees
WHERE salary>=10000
AND salary<=15000;
```
```sql
SELECT *
FROM employees
WHERE salary 
BETWEEN 10000 AND 15000;
```
<br>

***

### 문제 10
<br>
```
EMPLOYEES 테이블에서 last_name이 "S"로 시작하는 사원의 last_name, first_name 을 출력하세요.
```
<br>
```sql
SELECT last_name, first_name
FROM employees
WHERE last_name like 'S%';
```
<br>

***

### 문제 11
<br>
```
last_name의 세번째 문자가 "o"인 모든 사원의 last_name을 출력하세요.
```
<br>
```sql
SELECT last_name
FROM employees
WHERE last_name like '__o%';
```
<br>

***

### 문제 12 -ESCAPE 식별자

<br>
```
employees 테이블에 있는 데이터 중에 job_id에 SA_ 문자열로 시작되는 사원들의 employee_id, last_name, job_id를 출력하세요.
```
<br>
```sql
SELECT employee_id, last_name, job_id
FROM employees
WHERE job_id like 'SA\_%' escape '\';
```
<br>

***

### 문제 13
<br>
```
employees 테이블에 있는 데이터에서 job_id컬럼의 값이  SA로 시작하고  10000 이상의 salary(급여)를 받는 사원들의 모든 정보를 출력하세요.
```
<br>
```sql
SELECT *
FROM employees
WHERE job_id like 'SA%'
AND salary >=10000;
```
<br>

***

### 문제 14
<br>
```
employees 테이블에서  job_id 컬럼의 값이  SA로 시작하거나 10000 이상의 salary(급여)를 받는 사원들의 모든 정보를 출력하세요.

```
<br>
```sql
SELECT *
FROM employees
WHERE job_id  like 'SA%'
OR salary>=10000;
```
<br>

***

### 문제 15 -NOT IN 연산자

<br>
```
employees 테이블에서  job_id컬럼의 값이  IT_PROG, ST_CLERK , SA_REP가 아닌 모든 사원의 last_name, job_id를  출력해주세요.
```
<br>
```sql
SELECT last_name, job_id
FROM employees
WHERE job_id != 'IT_PROG'
AND job_id != 'ST_CLERK'
AND job_id != 'SA_REP';
```
```sql
SELECT last_name, job_id
FROM employees
WHERE job_id 
NOT IN ('IT_PROG','ST_CLERK','SA_REP');
```
<br>

***

### 문제 16 -TO_DATE() 형 변환

<br>
```
employees 테이블에 있는 데이터에서 job_id컬럼의 값이  SA로 시작하고  10000 이상의 salary(급여)를 받고 2005년도에 입사한(hire_date) 모든 사원들의 정보를 출력하세요.
```
<br>
```sql
DESC employees

SELECT *
FROM employees
WHERE job_id like 'SA%'
AND salary>=10000
AND hire_date >= to_date('2005-01-01','YYYY-MM-DD')
AND hire_date < to_date('2006-01-01','YYYY-MM-DD');
```
```sql
SELECT *
FROM employees
WHERE job_id like 'SA%'
AND salary>=10000
AND hire_date
BETWEEN to_date('2005-01-01','YYYY-MM-DD') 
AND to_date('2005-12-31 23:59:59','YYYY-MM-DD HH24:MI:SS');
```
<br>

***

### 문제 17 -연산자 우선순위

<br>
```
employees 테이블에서 job_id 컬럼의 값이 SA_REP 또는 AD_PRES 사원들 중에 급여가 10000 초가 한 사원들의 모든 정보를 출력하세요.
```
<br>
```sql
SELECT *
FROM employees
WHERE (job_id = 'SA_REP'
OR job_id = 'AD_PRES')
AND salary>10000;
```
```sql
SELECT *
FROM employees
WHERE job_id IN ('SA_REP','AD_PRES')
AND salary>10000;
```
<br>

***

### 문제 18 -LIKE, INSTR(), SUBSTR()

<br>
```
employees 테이블에 last_name 컬럼의 값 중에  "J" 또는 "A" 또는 "M"으로 시작하는 사원들의 last_name(첫번째 문자는
대문자, 나머지는 모두 소문자)과 last_name의 길이를 표시하는 query 를 작성합니다.
사원들의 last_name을 기준으로 결과를 오름차순 정렬해 주세요.
```
<br>
```sql
SELECT INITCAP(last_name) AS "LAST NAME",LENGTH(last_name) AS "LENGTH"
FROM employees
WHERE last_name like 'J%'
OR last_name like 'A%'
OR last_name like 'M%'
ORDER BY last_name;
```
```sql
SELECT INITCAP(last_name) AS "LAST NAME",
LENGTH(last_name) AS "LENGTH"
FROM employees
WHERE instr(last_name,'J')=1
OR instr(last_name,'A')=1
OR instr(last_name,'M')=1
ORDER BY last_name;
```
```sql
SELECT INITCAP(last_name) AS "LAST NAME",
LENGTH(last_name) AS "LENGTH"
FROM employees
WHERE SUBSTR(last_name,1,1)='J'
OR SUBSTR(last_name,1,1)='M'
OR SUBSTR(last_name,1,1)='A'
ORDER BY last_name;
```
```sql
SELECT INITCAP(last_name), LENGTH(last_name)
FROM employees
WHERE SUBSTR(last_name,1,1) IN ('J','M','A')
ORDER BY last_name;
```
<br>

***

### 문제 19 -LIKE, INSTR(), SUBSTR()

<br>
```
employees테이블에서 department_id(부서코드)가 50번 사원들 중에 last_name에 두번째 위치에 "a"글자가 있는 사원들을 조회하세요. 
```
<br>
```sql
SELECT *
FROM employees
WHERE department_id = 50
AND last_name like '_a%';
```
```sql
SELECT *
FROM employees
WHERE department_id = 50
AND INSTR(last_name,'a',1,1) = 2;
```
```sql
SELECT *
FROM employees
WHERE department_id = 50
AND SUBSTR(last_name,2,1)='a';
```
<br>

***

### 문제 20 -NEXT_DAY(), ADD_MONTHS()

<br>
```
사원의 last_name,hire_date 및 근무 6 개월 후 월요일에 해당하는 날짜를 조회하세요. 열별칭은 REVIEW 로 지정합니다. 
```
<br>
```sql
SELECT last_name, hire_date, NEXT_DAY(ADD_MONTHS(hire_date,6),'월요일') REVIEW 
FROM employees;
```
<br>

***

### 문제 21 -MONTHS_BETWEEN()

<br>
```
15년 이상 근무한 사원들의 employee_id(사원번호), hire_date(입사일), 근무개월수를 조회하세요.
```
<br>
```sql 
SELECT employee_id, hire_date, MONTHS_BETWEEN(sysdate,hire_date) AS "근무개월수"
FROM employees
WHERE MONTHS_BETWEEN(sysdate,hire_date)>=12*15;
```
<br>

***

### 문제 22 -LIKE, SUBSTR(), INSTR()

<br>
```
employees(사원)테이블에 있는 last_name의 세번째 문자가 'a' 또는 'e'가 포함된 모든 사원의 last_name을 조회하세요.

```
<br>
```sql
SELECT last_name
FROM employees
WHERE last_name like '__a%'
OR last_name like '__e%';
```
```sql
SELECT last_name
FROM employees
WHERE SUBSTR(last_name,3,1)='a'
OR SUBSTR(last_name,3,1)='e';
```
```sql
SELECT last_name
FROM employees
WHERE INSTR(last_name,'a')=3
OR INSTR(last_name,'a',1,2)=3
OR INSTR(last_name,'a',1,3)=3
OR INSTR(last_name,'e')=3
OR INSTR(last_name,'e',1,2)=3
OR INSTR(last_name,'e',1,3)=3;
```
```sql
--INSTR() 함수에서 시작 값을 바꾸지 않는 것이 좋다.
SELECT last_name
FROM employees
WHERE INSTR(last_name,'a',3,1)=3
OR INSTR(last_name,'e',3,1)=3;
```
<br>

***

### 문제 23

<br>
```
employees(사원)테이블에 있는  80번 부서(department_id) 사원중에 commission_pct 값이 0.2 이고 job_id는 SA_MAN인 사원의 employee_id, last_name, salary를 조회하세요.
```
<br>
```sql
SELECT employee_id, last_name, salary
FROM employees
WHERE department_id=80
AND commission_pct=0.2
AND job_id='SA_MAN';
```
<br>

***

### 문제 24 -원하는 형식으로 날짜 출력 TO_CHAR()

<br>
```
사원의 employees(사원)테이블에 있는 last_name,hire_date 및 근무 6 개월 후 첫번째 월요일에 해당하는 급여 협상 날짜를 표시합니다. 
             열 레이블을 REVIEW 로 지정합니다. 
            날짜는 "월요일, the Second of 4, 2007"과 유사한 형식으로 나타나도록 지정합니다.



<화면예>
LAST_NAME      HIRE_DATE    REVIEW
-------------------- --------------    ----------------------------------------------------------------------------------------
Abel                 04/05/11 	월요일, the Fifteenth of 11, 2004
Ande                08/03/24 	월요일, the Twenty-Ninth of 09, 2008
Atkinson           05/10/30 	월요일, the First of 05, 2006
```
<br>
```sql
SELECT last_name, hire_date, 
TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date,6),'월요일'),'day", the" ') ||
INITCAP(TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date,6),'월요일'),'ddspth')) ||
TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date,6),'월요일'),'"of" mm, yyyy') AS "PREVIEW"
FROM employees;
```
```sql
SELECT last_name, hire_date,
TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date,6),'월요일'),'day, "the" Ddspth "of" MM, YYYY') AS "PREVIEW"
FROM employees;
```
<br>

***

### 문제 25
<br>

```
employees(사원) 테이블에서  일요일에 입사한 사원의 정보를 조회하세요.
```
<br>
```sql
SELECT *
FROM employees
WHERE TO_CHAR(hire_date,'day')='일요일';
```
```sql
SELECT *
FROM employees
WHERE TO_CHAR(hire_date,'d')='1';
```
<br>

***

### 문제 26 -TO_CHAR(), MOD(), TO_NUMBER()

<br>
```
짝수달에 입사한 사원의 정보를 조회하세요.
```
<br>
```sql
SELECT *
FROM employees
WHERE MOD(TO_CHAR(hire_date,'mm'),2)='0';
```
```sql
SELECT *
FROM employees
WHERE MOD(TO_NUMBER(TO_CHAR(hire_date,'mm')),2)=0;
```
<br>

***

### 문제 27 -ALTER SESSION SET, TO_DATE()

<br>
```
2006년도에 홀수 달에 입사한 사원의 employee_id, last_name, hire_date를 조회하세요.
```
<br>
```sql
ALTER SESSION SET NLS_DATE_FORMAT='yyyymmdd';

SELECT employee_id, last_name, hire_date
FROM employees
WHERE MOD(TO_CHAR(hire_date,'mm'),2)='1'
AND TO_CHAR(hire_date,'yyyy')='2006';
```
```sql
SELECT employee_id, last_name, hire_date
FROM employees
WHERE hire_date>=TO_DATE('2006/01/01','yyyy/mm/dd')
AND hire_date<TO_DATE('2007/01/01','yyyy/mm/dd')
AND MOD(TO_NUMBER(TO_CHAR(hire_date,'mm')),2)=1;
```
<br>

***

### 문제 28 -LPAD(), RPAD()

<br>

```
아래 화면의 결과 처럼 사원의  last_name,  salary, salary 값을 1000당 별표를 하나를 출력하는  query문을 작성하세요. 

LAST_NAME      SALARY STAR
-------------------- ---------- --------------------------------------------------
King                   26400   **************************
Kochhar              18700   ******************
De Haan              17000   *****************
.....
```

<br>

```sql
SELECT last_name, salary, LPAD('*',TRUNC(salary/1000),'*') AS "STAR"
FROM employees
ORDER BY salary desc;
```
* 위 sql문은 salary값이 1000이상이라는 조건이 있어야함
* 공백을 넣어서 모든 조건에 부합하게 만듦

```sql
SELECT last_name, salary, LPAD(' ',TRUNC(salary/1000)+1,'*') AS "STAR"
FROM employees
ORDER BY salary desc;
```

<br>

***

### 문제 29 (~33) - 시간 계산 응용

<br>

```
아래 화면결과 처럼 출력하세요.

<화면 출력>

현재날짜시간
---------------------------------------------------------
현재 서버의 날짜 시간 : 20180530 09:35:46 오전
```

<br>

```sql
SELECT TO_CHAR(sysdate, 'YYYYMMDD hh24:mi:ss am') AS "현재날짜시간"
FROM dual;
```

<br>

***

### 문제 30 -TO_DSINTERVAL()

<br>

```
아래 화면결과 처럼 출력하세요.


<화면 출력>

하루전
-----------------------------------------------------------
서버의 시간을 기준으로 하루 전 : 20180529 09:40:02
```

<br>

```sql
SELECT TO_CHAR(sysdate-1, '"서버의 시간을 기준으로 하루 전 :" yyyymmdd hh24:mi:ss') AS "하루전"
FROM dual;
```

```sql
SELECT '서버의 시간을 기준으로 하루 전 : ' || 
TO_CHAR(sysdate-TO_DSINTERVAL('1 00:00:00'), 'yyyymmdd hh24:mi:ss') AS "하루전"
FROM dual;
```

<br>

***

### 문제 31

<br>

```
아래 화면결과 처럼 출력하세요.

<화면 출력>

1시간전
---------------------------------------------------------
서버의 시간을 기준으로 1시간 전 : 20180530 08:43:25
```

<br>

```sql
SELECT TO_CHAR((sysdate-(1/24)), '"서버의 시간을 기준으로 1시간 전 :" yyyymmdd hh24:mi:ss') AS "1시간전"
FROM dual;
```
```sql
SELECT '서버의 시간을 기준으로 1시간 전 : ' || 
TO_CHAR(sysdate-TO_DSINTERVAL('0 01:00:00'), 'yyyymmdd hh24:mi:ss') AS "1시간전"
FROM dual;
```

<br>

***

### 문제 32

<br>

```
<화면 출력>

5분전
----------------------------------------------------------
서버의 시간을 기준으로 5분 전 : 20180530 09:38:57
```

<br>

```sql
SELECT TO_CHAR((sysdate-(5/(24*60))), '"서버의 시간을 기준으로 5분 전 :" yyyymmdd hh24:mi:ss') AS "5분전"
FROM dual;
```
```sql
SELECT TO_CHAR(sysdate-TO_DSINTERVAL('0 00:05:00'), '"서버의 시간을 기준으로 5분 전 :" SELECT '서버의 시간을 기준으로 5분 전 : ' || 
TO_CHAR(sysdate-TO_DSINTERVAL('0 00:05:00'), 'yyyymmdd hh24:mi:ss') AS "5분전"
FROM dual;
```

<br>

***

### 문제 33

<br>

```
아래 화면결과 처럼 출력하세요.

<화면 출력>

10초전
---------------------------------------------------------
서버의 시간을 기준으로 10초 전 : 20180530 09:44:39
```

<br>

```sql
SELECT TO_CHAR(sysdate-(10/(24*60*60)), '"서버의 시간을 기준으로 10초 전 :" yyyymmdd hh24:mi:ss') AS "10초전"
FROM dual;
```
```sql
SELECT '서버의 시간을 기준으로 10초 전 : ' || 
TO_CHAR(sysdate-TO_DSINTERVAL('0 00:00:10'), 'yyyymmdd hh24:mi:ss') AS "10초전"
FROM dual;
```

<br>

***

### 문제 34 -CASE 연산자

<br>

```
JOB_ID 열의 값을 기준으로 모든 사원의 등급(GRADE)을 표시하는 query 를 작성하세요.

<화면예>

JOB_ID	 	GRADE
-----------		---------	
AD_PRES 		A
ST_MAN 		B
IT_PROG 		C
SA_REP 		D
ST_CLERK 	E
그외 JOB들은	Z
```

<br>

```sql
SELECT job_id,
    CASE job_id
      WHEN 'AD_PRES' THEN 'A'
      WHEN 'ST_MAN' THEN 'B'
      WHEN 'IT_PROG' THEN 'C'
      WHEN 'SA_REP' THEN 'D'
      WHEN 'ST_CLERK' THEN 'E'
      ELSE 'Z'
    END AS "GRADE"
FROM employees
ORDER BY GRADE;
```
<br>

***

### 문제 35 -NVL(),NVL2(),COALESCE(),CASE,DECODE()

<br>

```
사원테이블에  연봉을 계산 하는 쿼리문을 작성하세요 단 commission_pct 값이 
null 아니면 (salary*12) + (salary*12*commission_pct) 이값이 수행되고
null 이면 salary * 12 가 수행합니다. 수행 결과는 화면처럼 만드세요.
(nvl, nvl2,  coalesce, case, decode 함수를 사용하여 각각으로 수행해서 보고서 작성해 주세요)



LAST_NAME      SALARY COMMISSION_PCT  ANN_SAL
-------------------- ---------- -------------------------  ------------
OConnell              2600                     	            31200
Russell                 14000                          .4     235200

```

<br>

NVL()
```sql
SELECT last_name, salary, commission_pct,
  salary*12+(salary*12*NVL(commission_pct,0)) AS "ANN_SAL"
FROM employees
ORDER BY ANN_SAL desc;
```
<br>

NVL2()
```sql
SELECT last_name, salary, commission_pct,
  NVL2(commission_pct,(salary*12) + (salary*12*commission_pct),salary*12) AS "ANN_SAL"
FROM employees
ORDER BY ANN_SAL desc;
```
<br>
COALESCE()
```sql
SELECT last_name, salary, commission_pct,
  COALESCE((salary*12)+(salary*12*commission_pct),salary*12) AS "ANN_SAL"
FROM employees
ORDER BY ANN_SAL desc;

```
<br>
CASE
```sql
SELECT last_name, salary, commission_pct,
  CASE 
    WHEN commission_pct IS NULL THEN salary*12
    ELSE (salary*12) + (salary*12*commission_pct)
  END AS "ANN_SAL"
FROM employees
ORDER BY ANN_SAL desc; 
```
```sql
SELECT last_name, salary, commission_pct,
  CASE NULL
    WHEN NULL THEN salary*12
    ELSE (salary*12) + (salary*12*commission_pct)
  END AS "ANN_SAL"
FROM employees
ORDER BY ANN_SAL desc;  


>(NULL)

/*
NULL을 사용할 때는 항상 조심을 하자
CASE에서는 IS NULL 연산자를 써서 NULL 처리해야.
*/
```
<BR>
DECODE()
```sql
SELECT last_name, salary, commission_pct,
  DECODE(commission_pct,
        null,salary*12,
            (salary*12)+(salary*12*commission_pct)
        ) AS "ANN_SAL"
FROM employees
ORDER BY ANN_SAL desc; 
```

<br>

***

### 문제 36 -GROUP FUNCTION

<br>

```
모든 사원의 최고급여, 최저급여, 합계 및 평균 급여를 찾습니다. 
열 레이블을 각각 Maximum, Minimum, Sum 및 Average 로 지정합니다. 
결과를 소수점은 반올림해서 정수값으로 출력하세요.

   Maximum    Minimum        Sum    Average
  -------------- --------------   ----------   ------------
        24000          2100     691416        6462
```

<br>

```sql
SELECT MAX(salary) AS "Maxium", 
       MIN(salary) AS "Minium",
       SUM(salary) AS "Sum",
       ROUND(AVG(salary),0) AS "Average"
FROM employees;
```

<br>

***

### 문제 37 -GROUP FUNCTION

<br>

```
2008년도에 입사한 사원들의 job_id별 인원수를 구하고 인원수가 많은 순으로 출력하세요. 

JOB_ID     COUNT(*)
---------- ---------------
SA_REP              6 
SH_CLERK          2 
ST_CLERK          2 
SA_MAN            1 
```

<br>

```sql
SELECT job_id, COUNT(*)
FROM employees
WHERE hire_date >= TO_DATE('2008/01/01', 'yyyy/mm/dd')
AND hire_date < TO_DATE('2009/01/01', 'yyyy/mm/dd')
GROUP BY job_id
ORDER BY COUNT(*) desc;
```

<br>

***

### 문제 38 -WHERE절과 HAVING절

<br>

```
job_id별로 총액급여를 구합니다. 단 CLERK글자가 있는 job_id는 제외하고 
총액급여는 13000가 넘는 정보를 출력하면서 총액 급여를 기준으로 내림차순 정렬하세요.
```

<br>

```sql
--잘못된 코드! 주의!

SELECT job_id, SUM(salary) AS "SUM_SALARY"
FROM employees
HAVING job_id NOT LIKE '%CLERK%' --HAVING절에서 ROW를 제한하면 안된다 (HAVING절 참고)
AND SUM(salary) > 13000
GROUP BY job_id
ORDER BY SUM_SALARY desc;
```

```sql
SELECT job_id, SUM(salary) AS "SUM_SALARY"
FROM employees
WHERE job_id NOT like '%CLERK%'
HAVING SUM(salary) > 13000
GROUP BY job_id
ORDER BY SUM_SALARY desc;
```

<br>

***

### 문제 39 -날짜 추출 방법 TO_CHAR(), EXTRACT()

<br>

```
입사한 년도별로 급여의 총액을 출력하세요.
```

<br>

```sql
SELECT TO_CHAR(hire_date,'yyyy') AS "HIRE_YEAR", SUM(salary)
FROM employees
GROUP BY TO_CHAR(hire_date,'yyyy')
ORDER BY "HIRE_YEAR";
```
```sql
SELECT EXTRACT(year from hire_date), SUM(salary)
FROM employees
GROUP BY EXTRACT(year from hire_date);
```

<br>

***

### 문제 40

```
입사한 달별 인원수를 출력해주세요.
```

<br>

```sql
SELECT  TO_CHAR(hire_date, 'mm"월"') AS "HIRE_MON", COUNT(*)
FROM employees
GROUP BY TO_CHAR(hire_date,'mm"월"')
ORDER BY HIRE_MON;
```

<br>

***

### 문제 41 -COUNT()와 SUM(), CASE와 DECODE() (=문제 73)

<br>

```
사원의 총수와 2005년, 2006년, 2007년, 2008년에 입사한 사원의 수 출력하세요.

   TOTAL    2005     2006     2007     2008
   -------- ---------- ---------- ---------- ----------
     107         29         24         19         11
```

<br>

건 수를 셀 때는 COUNT()를 사용하자.

<br>

COUNT()와 CASE() 
```sql
SELECT 
  COUNT(*) AS "TOTAL",
  COUNT(
  CASE TO_CHAR(hire_date,'yyyy') 
    WHEN '2005' THEN 1 --THEN 뒤에 1 대신 다른 값을 넣어도 상관없음
  END
  ) AS "2005",
  COUNT(
  CASE TO_CHAR(hire_date,'yyyy')
    WHEN '2006' THEN 1
  END
  ) AS "2007",
  COUNT(
  CASE TO_CHAR(hire_date,'yyyy')
    WHEN '2007' THEN 1
  END 
  ) AS "2007",
  COUNT(
  CASE TO_CHAR(hire_date,'yyyy')
    WHEN '2008' THEN 1
  END 
  ) AS "2008"
FROM employees;
```
<br>

SUM()과 DECODE()
```sql
SELECT 
  COUNT(*) AS "TOTAL",
  SUM(DECODE(TO_CHAR(hire_date,'yyyy'),'2005',1)) "2005",
  SUM(DECODE(TO_CHAR(hire_date,'yyyy'),'2006',1)) "2005",
  SUM(DECODE(TO_CHAR(hire_date,'yyyy'),'2007',1)) "2007",
  SUM(DECODE(TO_CHAR(hire_date,'yyyy'),'2008',1)) "2008"
FROM employees;
```

동일한 행동이 여러 발생 -> 악성코드! -> 현장에서는 이런 식으로 사용하지말자!


<br>

***

### 문제 42 (~47) -JOIN

<br>

```
모든 사원의 last_name, department_id, department_name을 표시하기 위한 query 를 작성합니다.
```

<br>

ORACLE
```sql
desc employees
desc departments

SELECT e.last_name, e.department_id, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id(+);
```

<br>

ANSI 표준
```sql
SELECT e.last_name, e.department_id, d.department_name
FROM employees e LEFT OUTER JOIN departments d
ON e.department_id = d.department_id;
```

<br>

***

### 문제 43

<br>

```
부서 80에 속하는 last_name, job_id, department_name, city를 표시하기 위한 query 를 작성합니다.
```

<br>

ORACLE
```sql
desc employees
desc departments
desc locations

SELECT e.last_name, e.job_id, d.department_name, l.city 
FROM employees e, departments d, locations l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND d.department_id = 80;

--'부서 80에 속하는'이라는 조건이 있기에 outer join을 생각하지 않아도 됌
```

<br>

ANSI 표준
```sql
SELECT e.last_name, e.job_id, d.department_name, l.city 
FROM employees e JOIN departments d
ON e.department_id = d.department_id
LEFT OUTER JOIN locations l
ON d.location_id = l.location_id
WHERE d.department_id = 80;
```

<br>

***

### 문제 44

<br>

```
commission_pct 에 null이 아닌 모든 사원의 last_name, department_name, location_id, city를 표시하기 위한 query 를 작성합니다.
```

<br>

ORACLE
```sql
SELECT COUNT(*)
FROM employees
WHERE commission_pct IS NOT NULL;

SELECT e.last_name, d.department_name, l.location_id, l.city
FROM employees e, departments d, locations l
WHERE e.department_id = d.department_id(+)
AND d.location_id = l.location_id(+)
AND e.commission_pct IS NOT NULL;
```

<br>

ANSI 표준
```sql
SELECT e.last_name, d.department_name, l.location_id, l.city
FROM employees e LEFT OUTER JOIN departments d
ON e.department_id = d.department_id
LEFT OUTER JOIN locations l
ON d.location_id = l.location_id
WHERE e.commission_pct IS NOT NULL;
```

<br>

***

### 문제 45

<br>

```
last_name에 a(소문자)가 포함된 모든 사원의 last_name, department_name 을 표시하기 위한 query 를 작성합니다.
```

<br>

ORACLE
```sql
SELECT e.last_name, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id(+)
AND e.last_name LIKE '%a%';

SELECT COUNT(*)
FROM employees
WHERE last_name LIKE '%a%';
```
```sql
Ex. instr() 사용

SELECT e.last_name, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id(+)
AND instr(e.last_name,'a')>=1;
```

<br>

ANSI 표준
```sql
SELECT e.last_name, d.department_name
FROM employees e LEFT OUTER JOIN departments d
ON e.department_id = d.department_id
WHERE e.last_name LIKE '%a%';
```
```sql
Ex. instr() 사용

SELECT e.last_name, d.department_name
FROM employees e LEFT OUTER JOIN departments d
ON e.department_id = d.department_id
WHERE instr(e.last_name,'a')>=1;
```

<br>

***

### 문제 46

<br>

```
locations 테이블에 있는 city컬럼에  Toronto도시에서 근무하는 모든 사원의 
last_name, job_id, department_id, department_name 을 표시하기 위한 query 를 작성합니다.
```

<br>

ORACLE
```sql
SELECT COUNT(*)
FROM locations l, departments d, employees e
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Toronto';

SELECT e.last_name, e.job_id, d.department_id, d.department_name
FROM employees e, departments d, locations l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Toronto';
```

<br>

ANSI 표준
```sql
SELECT e.last_name, e.job_id, d.department_id, d.department_name
FROM employees e FULL OUTER JOIN departments d
ON e.department_id = d.department_id
FULL OUTER JOIN locations l
ON d.location_id = l.location_id
WHERE l.city = 'Toronto';
```

<br>

***

### 문제 47 -JOIN (악성코드 주의)

<br>

```
2006년도에 입사한 사원들의 부서이름별로 급여의 총액, 평균을 출력하세요.
```

<br>

ORACLE
```sql
SELECT COUNT(DISTINCT department_id)
FROM employees
WHERE TO_CHAR(hire_date,'yyyy')=2006;

SELECT d.department_name, SUM(e.salary), AVG(e.salary)
FROM departments d, employees e
WHERE d.department_id = e.department_id
AND TO_CHAR(e.hire_date, 'yyyy') = 2006
GROUP BY d.department_name;

--데이터 타입을 바꿈 -> FULL SCAN으로 바뀜->FULL SCAN
--코드가 길어지더라도 아래같이 사용하자.
```
```sql
SELECT d.department_name, SUM(e.salary), AVG(e.salary)
FROM departments d, employees e
WHERE d.department_id = e.department_id
AND e.hire_date >= to_date('2006/01/01','yyyy/mm/dd')
AND e.hire_date < to_date('2007/01/01','yyyy/mm/dd')
GROUP BY d.department_name;
```

<br>

ANSI 표준
```sql
SELECT d.department_name, SUM(e.salary), AVG(e.salary)
FROM departments d JOIN employees e
ON d.department_id = e.department_id
WHERE TO_CHAR(e.hire_date, 'yyyy') = 2006
GROUP BY d.department_name;

--위와 같은 이유. 주의하자.
```
```sql
SELECT d.department_name, SUM(e.salary), AVG(e.salary)
FROM departments d JOIN employees e
ON d.department_id = e.department_id
WHERE e.hire_date >= to_date('2006/01/01','yyyy/mm/dd')
AND e.hire_date < to_date('2007/01/01','yyyy/mm/dd')
GROUP BY d.department_name;
```

<br>

***

### 문제 48

<br>

```
2006년도에 입사한 사원들의 도시이름별로 급여의 총액, 평균을 출력하세요.
```

<br>

ORACLE
```sql
SELECT COUNT(DISTINCT l.city)
FROM locations l, employees e, departments d
WHERE l.location_id = d.location_id(+)
AND d.department_id = e.department_id(+)
AND e.hire_date >= TO_DATE('2006/01/01','yyyy/mm/dd')
AND e.hire_date < TO_DATE('2007/01/01','yyyy/mm/dd');


SELECT l.city, SUM(e.salary), AVG(e.salary)
FROM locations l, employees e, departments d
WHERE e.department_id = d.department_id
AND l.location_id = d.location_id
AND e.hire_date >= TO_DATE('2006/01/01','yyyy/mm/dd')
AND e.hire_date < TO_DATE('2007/01/01','yyyy/mm/dd')
GROUP BY l.city;
```

<br>

ANSI 표준
```sql
SELECT l.city, SUM(e.salary), AVG(e.salary)
FROM locations l JOIN departments d
ON l.location_id = d.location_id
JOIN employees e
ON e.department_id = d.department_id
WHERE e.hire_date >= TO_DATE('2006/01/01','yyyy/mm/dd')
AND e.hire_date < TO_DATE('2007/01/01','yyyy/mm/dd')
GROUP BY l.city;
```

<br>

***

### 문제 49

<br>

```
2007년도에 입사한 사원들의 도시이름별로 급여의 총액, 평균을 출력하세요. 
단 부서 배치를 받지 않는 사람들의 급여의 총액, 평균도 구하세요.
```

<br>

ORACLE
```sql
SELECT l.city, SUM(e.salary), AVG(e.salary)
FROM locations l, employees e, departments d
WHERE e.department_id = d.department_id(+)
AND l.location_id(+) = d.location_id
AND e.hire_date >= TO_DATE('2007/01/01','yyyy/mm/dd')
AND e.hire_date < TO_DATE('2008/01/01','yyyy/mm/dd')
GROUP BY l.city;
```

<br>

ANSI 표준
```sql
SELECT l.city, SUM(e.salary), AVG(e.salary)
FROM locations l JOIN departments d
ON l.location_id = d.location_id
RIGHT OUTER JOIN employees e
ON d.department_id = e.department_id
WHERE e.hire_date >= TO_DATE('2007/01/01','yyyy/mm/dd')
AND e.hire_date < TO_DATE('2008/01/01','yyyy/mm/dd')
GROUP BY l.city;
```

<br>

***

### 문제 50

<br>

```
사원들의 사번, 급여, 급여등급, 부서이름을 출력하세요.
부서배치를 받지 않는 사원은 제외시켜주세요.
```

<br>

ORACLE
```sql
SELECT e.employee_id, e.salary, l.grade_level, d.department_name
FROM employees e, job_grades l, departments d
WHERE e.salary BETWEEN l.lowest_sal AND l.highest_sal
AND e.department_id = d.department_id
ORDER BY 1;
```

<br>

ANSI 표준
```sql
SELECT e.employee_id, e.salary, l.grade_level, d.department_name
FROM employees e JOIN job_grades l
ON e.salary BETWEEN l.lowest_sal AND l.highest_sal
JOIN departments d
ON e.department_id = d.department_id
ORDER BY 1;
```

<br>

***

### 문제 51

<br>

```
사원들의 사번, 급여, 급여등급, 부서이름, 근무 도시 정보를 출력하세요.
부서배치를 받지 않는 사원도 포함시켜주세요.
```

<br>

ORACLE
```sql
SELECT e.employee_id, e.salary, l.grade_level, p.city
FROM employees e, job_grades l, locations p, departments d
WHERE e.salary BETWEEN l.lowest_sal AND l.highest_sal
AND e.department_id = d.department_id(+) 
--여기서 e.department_id는 join 된 결과(active set)의 department_id
AND d.location_id = p.location_id(+);
```

<br>

ANSI 표준
```sql
SELECT e.employee_id, e.salary, l.grade_level, p.city
FROM employees e JOIN job_grades l
ON e.salary BETWEEN l.lowest_sal AND l.highest_sal
LEFT OUTER JOIN departments d
ON e.department_id = d.department_id
LEFT OUTER JOIN locations p
ON d.location_id = p.location_id
ORDER BY 1;
```

<br>

***

### 문제 52

<br>

```
사원들의 last_name,salary,grade_level, department_name을 출력하는데 last_name에 a문자가 2개 이상 포함되어 있는 사원들을 출력하세요.
```

<br>

ORACLE
```sql
SELECT e.last_name, e.salary, l.grade_level, d.department_name
FROM employees e, job_grades l, departments d
WHERE e.department_id = d.department_id
AND e.salary BETWEEN l.lowest_sal AND l.highest_sal
AND e.last_name LIKE '%a%a%';
```
```sql
Ex. instr() 사용

SELECT e.last_name, e.salary, j.grade_level, d.department_name
FROM employees e, departments d, job_grades j
WHERE e.salary between j.lowest_sal and j.highest_sal
AND e.department_id = d.department_id
AND instr(e.last_name,'a',1,2)>1;
```

<br>

ANSI 표
```sql
SELECT e.last_name, e.salary, l.grade_level, d.department_name
FROM employees e JOIN job_grades l
ON e.salary BETWEEN l.lowest_sal AND l.highest_sal
JOIN departments d
ON e.department_id = d.department_id
AND e.last_name LIKE '%a%a%';
```

<BR>

***

### 문제 53 -단일행 서브쿼리

<br>

```
141번 사원의 job_id와 동일한 job_id 가진 사원들 중에 141번 사원의 급여보다 더 많이 받는 사원을 출력해주세요.
```

<br>

```sql
SELECT *
FROM employees
WHERE job_id = (
  SELECT job_id
  FROM employees
  WHERE employee_id = 141
)
AND salary > (
  SELECT salary
  FROM employees
  WHERE employee_id = 141
);
```

<br>

***

### 문제 54

<br>

```
최소 월급을 받은 사원들의 정보를 출력해주세요.
```

<br>

```sql
SELECT *
FROM employees
WHERE salary = (
  SELECT MIN(salary)
  FROM employees
);
```

<br>

***

### 문제 55 -서브쿼리, GROUP함수

<br>

```
평균 급여가 가장 낮은 job_id를 찾아 주세요.
```

<br>

```sql
SELECT job_id
FROM employees
HAVING AVG(salary) = (
  SELECT MIN(AVG(salary))
  FROM employees
  GROUP BY job_id
)
GROUP BY job_id;
```

<br>

***

### 문제 56

<br>

```
부서별로 최소 급여자들을 출력해주세요.
```

<br>

```sql
SELECT *
FROM employees
WHERE salary IN (
  SELECT MIN(salary)
  FROM employees
  GROUP BY department_id
  );

--한 부서의 최소값이 다른 부서에 영향을 줄 수 있다
```

<br>

***

### 문제 57

<br>

```
last_name 에 문자 "u"가 포함된 사원과 같은 부서에 근무하는 모든 사원의 employee_id, last_name 을 출력하세요.
```

<br>

```sql
SELECT employee_id, last_name
FROM employees
WHERE employee_id IN (
  SELECT employee_id
  FROM employees
  WHERE last_name like '%u%'
);
```

<br>

***

### 문제 58 -조인, 서브쿼리

<br>

```
부서 위치(location_id) ID 가 1700 인 모든 사원의 last_name, department_id, job_id 를 출력하세요.(조인, 서브쿼리)
```

<br>

조인
```sql
SELECT e.last_name, d.department_id, e.job_id
FROM employees e JOIN departments d
ON e.department_id = d.department_id
WHERE d.location_id = 1700;
```

<br>

서브쿼리
```sql
SELECT last_name, department_id, job_id
FROM employees
WHERE department_id IN (
  SELECT department_id
  FROM departments
  WHERE location_id = 1700
);
```

<br>

***

### 문제 59 -조인, 서브쿼리

<br>

```
King 에게 보고하는 모든 사원의 last_name 및 salary 출력하세요.(조인, 서브쿼리)
```

<br>

```sql
SELECT e.last_name, e.salary
FROM employees e, employees m
WHERE e.manager_id = m.employee_id
AND m.last_name = 'King';
```

<br>

서브쿼리
```sql
SELECT last_name, salary
FROM employees
WHERE manager_id IN (
  SELECT employee_id
  FROM employees
  WHERE last_name = 'King'
);
```

<br>

***

### 문제 60

<br>

```
부서 이름(department_name) 이 Executive 부서의 모든 사원에 대한 department_id, last_name, job_id  출력하세요.
```
<br>

조인
```sql
SELECT e.department_id, e.last_name, e.job_id
FROM employees e, departments d
WHERE e.department_id = d.department_id
AND d.department_name = 'Executive';
```

<br>

서브쿼리
```sql
SELECT department_id, last_name, job_id
FROM employees
WHERE department_id = (
  SELECT department_id
  FROM departments
  WHERE department_name = 'Executive'
);
```

<br>

***

### 문제 61

<br>

```
60부서에 소속된 모든 사원의 급여(salary)보다 높은(max) 급여를 받는 모든 사원 출력하세요.
```

<br>

```sql
SELECT *
FROM employees
WHERE salary > (
  SELECT MAX(salary)
  FROM employees
  WHERE department_id = 60
);
```
```sql
SELECT *
FROM employees
WHERE salary > ALL(
  SELECT salary
  FROM employees
  WHERE department_id = 60
);
```
<br>

***

### 문제 62

<br>

```
전체 평균 급여보다 많은 급여를 받고 last_name에 "u"가 포함된 사원이 있는 부서에서 근무하는 모든 사원의 employee_id, last_name, salary 출력하세요
```

<br>

```sql
SELECT employee_id, last_name, salary
FROM employees
WHERE salary > (
  SELECT AVG(salary)
  FROM employees
)
AND department_id IN (
  SELECT department_id
  FROM employees
  WHERE last_name like '%u%'
);
```

<br>

***

### 문제 63 -서브쿼리, NULL, IN연산자

<br>

```
관리자 사원들의 정보를 출력해주세요 
```

<br>

```sql
SELECT *
FROM employees
WHERE employee_id IN (
  SELECT manager_id
  FROM employees
);
```

<br>

***

### 문제 64 -서브쿼리, NULL, NOT IN연산자

<br>

```
관리자가 아닌 사원들의 정보를 출력해 주세요
```

<br>

```sql
SELECT *
FROM employees
WHERE employee_id NOT IN(
  SELECT manager_id
  FROM employees
  WHERE manager_id IS NOT NULL
);

--(T AND NUL = NULL) 이기때문에 IS NOT NULL 사용
```

'NOT IN'를 사용할 때는 NULL값을 반드시 확인해야한다.

<br>

***

### 문제 65

<br>

```
last_name에 Davies 사원보다 늦게 입사한 사원 중에 급여가 Davies 사원의 급여 이하로 받고 있는 사원들을 출력해주세요.
```

<br>

서브쿼
```sql
SELECT *
FROM employees
WHERE salary <= (
  SELECT salary
  FROM employees
  WHERE last_name = 'Davies'
)
AND hire_date > (
  SELECT hire_date
  FROM employees
  WHERE last_name = 'Davies'
);
```

<br>

조인
```sql
SELECT e.*
FROM employees e, employees d
WHERE d.last_name = 'Davies'
AND e.salary <= d.salary
AND e.hire_date > d.hire_date;
```

<br>

***

### 문제 66 -Correlated subquery, Inline View

<br>

```
자신의 부서 평균 급여보다 더 많은 급여를 받는 사원들의 정보를 출력해주세요.
```

<br>

Correlated subquery
```sql
SELECT *
FROM employees o 
WHERE o.salary > (
  SELECT AVG(salary)
  FROM employees
  WHERE department_id = o.department_id
);
```
<br>

Inline view
```sql
SELECT e2.*
FROM (SELECT department_id, AVG(salary) avgsal --가상 컬럼
      FROM employees
      GROUP BY department_id) e1,              --'e1'이라는 가상테이블 
      employees e2
WHERE e1.department_id = e2.department_id
AND e1.avgsal < e2.salary;
```

<br>

***

### 문제 67 -Correlated subquery, Inline view

<br>

```
두 번이상 job_id를 바꾼 사원들의 정보를 출력해주세요.
```

<br>

Correalted subquery
```sql
SELECT *
FROM employees o
WHERE 2 <= (
  SELECT COUNT(*)
  FROM job_history
  WHERE employee_id = o.employee_id
);
```

<br>

Inline view
```sql
SELECT e2.*
FROM (SELECT COUNT(*) times, employee_id
      FROM job_history
      GROUP BY employee_id) e1,
      employees e2
WHERE e1.employee_id = e2.employee_id
AND e1.times > 1;
```
```sql
SELECT e2.*
FROM (SELECT employee_id
      FROM job_history
      GROUP BY employee_id
      HAVING COUNT(*) > 1) e1,
      employees e2
WHERE e1.employee_id = e2.employee_id;
```

<br>

***

### 문제 68 -상호관련서브쿼리, EXISTS연산자 (=문제 63)

<br>

```
관리자 사원들의 정보를 출력해주세요 
```

<br>

```sql
--문제 63번 답

SELECT *
FROM employees
WHERE employee_id IN (
  SELECT manager_id
  FROM employees
);
```

```sql
SELECT *
FROM employees o
WHERE EXISTS (  --Boolean 형식
  SELECT 'X'    --문법 오류를 방지하기위해 의미없는 'X'를 넣음
  FROM employees
  WHERE manager_id = o.employee_id
);

--후보행 값이 서브쿼리절에 존재하면 더이상 검색 안함.
```

<BR>

***

### 문제 69 -상호관련서브쿼리, EXISTS연산자 (=문제 64)


<br>

```
관리자가 아닌 사원에 대해서 출력해주세요.
```

<br>

```sql
--문제 64 답

SELECT *
FROM employees
WHERE employee_id NOT IN(
  SELECT manager_id
  FROM employees
  WHERE manager_id IS NOT NULL
);
```

```sql
SELECT *
FROM employees o
WHERE NOT EXISTS (
  SELECT 'X'
  FROM employees
  WHERE manager_id = o.employee_id
);
```

<br>

***

### 문제 70

<br>

```
사원이 없는 부서 정보만 출력해주세요.
```

<br>

NOT IN 연산자 사용
```sql
SELECT * 
FROM departments
WHERE department_id NOT IN (
  SELECT department_id
  FROM employees
  WHERE department_id IS NOT NULL
);
```

<br>

상호관련서브쿼리 사용
```sql
SELECT *
FROM departments o
WHERE NOT EXISTS (
  SELECT 'X'
  FROM employees
  WHERE department_id = o.department_id
);
```

<br>

***

### 문제 71

<br>

```
30번 부서에서 자신보다 입사일은 늦지만 Salary를 더많이 받는 사원을 출력하세요
```

<br>

```sql
SELECT e.*
FROM employees e
WHERE EXISTS (
  SELECT 'X'
  FROM employees
  WHERE department_id = e.department_id
  AND hire_date > e.hire_date
  AND salary > e.salary
)
AND e.department_id = 30;
```

<br>

```sql
SELECT *
FROM employees o 
WHERE o.salary < ANY(
  SELECT salary
  FROM employees
  WHERE department_id = o.department_id
  AND hire_date > o.hire_date
)
AND department_id = 30;
```

<br>

***

### 문제 72 -Inline view, Join

<br>

```
사원수가 3명 미만인 부서번호, 부서이름, 인원수를 출력하세요
```

<br>

Inline view
```sql
SELECT e.department_id, d.department_name, e.numb
FROM (SELECT department_id, COUNT(*) numb
      FROM employees
      GROUP BY department_id
      HAVING COUNT(*) < 3) e,
      departments d
WHERE e.department_id = d.department_id
ORDER BY 1;
```
```sql
SELECT e.department_id, d.department_name, e.numb
FROM (SELECT department_id, COUNT(*) numb
      FROM employees
      GROUP BY department_id) e,
      departments d
WHERE e.department_id = d.department_id
AND e.numb < 3
ORDER BY 1;
```

<br>

JOIN
```sql
SELECT d.department_id, d.department_name, COUNT(*)
FROM employees e, departments d
WHERE e.department_id = d.department_id
GROUP BY d.department_id, d.department_name
HAVING count(*) < 3
ORDER BY 1;
```

<br>

***

### 문제 73 -테이블 뒤집기 (=문제 41)

<br>

```
사원의 총수와 2005년, 2006년, 2007년, 2008년에 입사한 사원의 수 출력하세요. (Inline view로 생성하세요.)

    2005     2006     2007     2008
  ---------- ---------- ---------- ---------
    29         24         19         11
```

<br>

```sql
SELECT SUM(DECODE(y,'2005',cn)) "2005",
       SUM(DECODE(y,'2006',cn)) "2006",
       SUM(DECODE(y,'2007',cn)) "2007",
       SUM(DECODE(y,'2008',cn)) "2008"
FROM (SELECT TO_CHAR(hire_date,'yyyy') y, COUNT(*) cn
      FROM employees
      GROUP BY TO_CHAR(hire_date,'yyyy'));
      
--SUM() 대신 다른 그룹함수를 사용해도 된다.
```

<br>

***

### 문제 74

<br>

```
평균 급여가 가장 높은 부서의 부서 번호와 최고, 최저, 평균 급여를 출력하세요.
```

<br>

```sql
SELECT department_id, MAX(salary), MIN(salary), AVG(salary)
FROM employees
HAVING AVG(salary) = (
    SELECT MAX(AVG(salary))
    FROM employees
    GROUP BY department_id)
GROUP BY department_id;
```

<br>

***

### 문제 75

<br>

```
사원 수가 가장 많은 부서이름, 도시, 인원수를 출력해주세요.
```

<br>

```sql
SELECT d.department_name, l.city, e.cn
FROM (
     SELECT department_id, count(*) cn
     FROM employees
     GROUP BY department_id
     HAVING COUNT(*) = (
      SELECT MAX(COUNT(*))
      FROM employees
      GROUP BY department_id)) e, 
     departments d, 
     locations l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id;
```
```sql
SELECT d.department_name, d.city, e.cn
FROM (
     SELECT d.department_id, d.department_name, l.city
     FROM departments d, locations l
     WHERE d.location_id = l.location_id) d,
     (
     SELECT department_id, COUNT(*) cn
     FROM employees
     GROUP BY department_id) e
WHERE e.department_id = d.department_id(+)
AND e.cn = (
  SELECT MAX(COUNT(*))
  FROM employees
  GROUP BY department_id);
```

<br>

***

### 문제 76

<br>

```
사원 채용 수가 가장 많은 요일을 출력해주세요.
```

<br>

```sql
SELECT e.hiredate
FROM (
     SELECT TO_CHAR(hire_date,'day') hiredate, COUNT(*) cn
     FROM employees
     GROUP BY TO_CHAR(hire_date,'day')) e
WHERE e.cn = (
  SELECT MAX(COUNT(*))
  FROM employees
  GROUP BY TO_CHAR(hire_date,'day'));
```
```sql
SELECT TO_CHAR(hire_date, 'day')
FROM employees
GROUP BY TO_CHAR(hire_date, 'day')
HAVING COUNT(*) = (
  SELECT MAX(COUNT(*))
  FROM employees
  GROUP BY TO_CHAR(hire_date, 'day'));
```

<br>

***

### 문제 77

<br>

```
사원 채용 수가 가장 많은 요일에 입사한 사원들의 last_name, 요일을 출력해주세요.
```

<br>

```sql
SELECT last_name, to_char(hire_date, 'day') day
FROM employees
WHERE to_char(hire_date, 'day') IN (
  SELECT to_char(hire_date, 'day')
  FROM employees
  GROUP BY to_char(hire_date, 'day')
  HAVING COUNT(*) = (
    SELECT MAX(COUNT(*))
    FROM employees
    GROUP BY to_char(hire_date, 'day')));
```

<br>

***

### 문제 78 -테이블 뒤집기

<br>

```
부서별로 인원수를 출력주세요.


<화면결과> 

       10         20        30         40        50         60         70         80         90      100        110 부서가 없는 사원
---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ------------------
         1          2          6            1         45           5          1         34           3           6          2                    1
```

<br>

```sql
SELECT SUM(DECODE("id",10,cn)) "10",
       SUM(DECODE("id",20,cn)) "20",
       SUM(DECODE("id",30,cn)) "30",
       SUM(DECODE("id",40,cn)) "40",
       SUM(DECODE("id",50,cn)) "50",
       SUM(DECODE("id",60,cn)) "60",
       SUM(DECODE("id",70,cn)) "70",
       SUM(DECODE("id",80,cn)) "80",
       SUM(DECODE("id",90,cn)) "90",
       SUM(DECODE("id",10,cn)) "100",
       SUM(DECODE("id",110,cn)) "110",
       SUM(DECODE("id",NULL,cn)) "부서가 없는 사원"
FROM (
  SELECT department_id "id", COUNT(*) cn
  FROM employees
  GROUP BY department_id
  );
```

아래는 동일한 수행을 반복하기 때문에 쓰지말도록 하자

```sql
select count(decode(department_id,10,1)) "10",
       count(decode(department_id, 20,1)) "20",
       count(decode(department_id,30,1)) "30",
       count(decode(department_id,40,1)) "40",   
       count(decode(department_id,50,1)) "50",
       count(decode(department_id,60,1)) "60",
       count(decode(department_id,70,1)) "70",
       count(decode(department_id,80,1)) "80" ,
       count(decode(department_id,90,1)) "90",
       count(decode(department_id,100,1)) "100",  
       count(decode(department_id,110,1)) "110",
       count(decode(department_id,null,1)) "부서가 없는 사원"  
from employees;
```

<br>

***

### 문제 79 -multiple column subquery

<br>

```
부서 번호와 급여가 커미션을 받는 사원의 부서 번호 및 급여와 일치하는 모든  사원의 last_name, department_id, salary 를 표시하는 query 를 작성하세요.
```

<br>

```sql
SELECT last_name, department_id, salary
FROM employees
WHERE (department_id , salary) IN (
  SELECT department_id, salary
  FROM employees
  WHERE commission_pct IS NOT NULL
);
```

<br>

***

### 문제 80 -결측치 처리

<br>

```
급여와 커미션이 location_id가 1700 에 있는 사원의 급여 및 커미션과 일치하는 사원의 last_name, department_name, salary를 출력해주세요.
```

<br>

```sql
SELECT e.last_name, d.department_name, e.salary
FROM employees e, departments d
WHERE (e.salary, NVL(e.commission_pct,0)) IN (
  SELECT e.salary, NVL(e.commission_pct,0)
  FROM employees e, departments d
  WHERE d.location_id = 1700
  AND e.department_id = d.department_id
)
AND e.department_id = d.department_id;
```
```sql
SELECT e.last_name, d.department_name, e.salary
FROM employees e,
     (
     SELECT department_id, department_name
     FROM departments
     ) d
WHERE e.department_id = d.department_id
AND (e.salary, NVL(e.commission_pct,0)) IN (
  SELECT salary, NVL(commission_pct,0)
  FROM employees
  WHERE department_id IN (
    SELECT department_id
    FROM departments
    WHERE location_id = 1700
    )
  );
```

<br>

***

### 문제 81

<br>

```
Johnson 와 동일한 급여 및 커미션을 받는 모든 사원의 last_name, hire_date, salary, commission_pct를 표시하는 query 를 작성합니다.
단 결과에 Johnson 를 표시하지 마십시오.
```

<br>

```sql
SELECT last_name, hire_date, salary, commission_pct
FROM employees
WHERE (salary, NVL(commission_pct,0)) IN (
  SELECT salary, NVL(commission_pct,0)
  FROM employees
  WHERE last_name = 'Johnson'
)
AND last_name != 'Johnson';
```

<br>

***

### 문제 82 - WITH절

<br>

```
부서의 총 급여가 전체 부서의 평균 급여보다 많은 부서의 이름과 총 급여를 표시하도록 query를 작성하세요.
```

<br>

```sql
SELECT d.department_name, SUM(e.salary) "tot_sal"
FROM departments d, employees e
WHERE d.department_id = e.department_id
HAVING SUM(e.salary) > (
  SELECT AVG(SUM(salary))
  FROM employees
  WHERE department_id IS NOT NULL --NULL값의 포함 여부는 물어보고 할 것
  GROUP BY department_id
  )
GROUP BY d.department_name;
```
```sql
SELECT d.department_name, e.sumsal
FROM (
     SELECT department_id, SUM(salary) sumsal
     FROM employees
     GROUP BY department_id
     HAVING SUM(salary) > (
      SELECT AVG(sumsal) 
      FROM (
        SELECT SUM(salary) sumsal
        FROM employees
        GROUP BY department_id
      ))) e, 
     departments d
where e.department_id=d.department_id;
```
```sql
WITH
dept_cost AS (
  SELECT d.department_name, SUM(salary) AS sumsal
  FROM employees e, departments d
  WHERE e.department_id = d.department_id --NULL값을 포함하려면 OUTER JOIN
  GROUP BY d.department_name
  ),
avg_cost AS (
  SELECT (sum(sumsal)/COUNT(*)) AS deptavg
  FROM dept_cost
  )
SELECT *
FROM dept_cost
WHERE sumsal > (
  SELECT deptavg
  FROM avg_cost
  );
```

<br>

***

### 문제 83 -상호관련서브쿼리 중요!

<br>

```
job_id가  ST_CLERK 을 포함하지 않는 부서에 대한 department_id를 출력해주세요.
```

<br>

```sql
SELECT department_id
FROM departments d
WHERE NOT EXISTS (
  SELECT 'X'
  FROM employees
  WHERE job_id = 'ST_CLERK'
  AND department_id = d.department_id);
```
```sql
SELECT department_id
FROM departments
MINUS
SELECT department_id
FROM employees
WHERE job_id = 'ST_CLERK';
```
<br>

***

### 문제 84

<br>

```
부서가 소재하지 않는 국가의 리스트가 필요합니다. 해당 국가의 country_id, country_name을 출력해주세요.
```

<br>

```sql
SELECT country_id, country_name
FROM countries c
WHERE NOT EXISTS (
  SELECT 'X'
  FROM departments d, locations l
  WHERE d.location_id = l.location_id
  AND l.country_id = c.country_id);
```

```sql
SELECT country_id,country_name
FROM countries
MINUS
SELECT l.country_id,c.country_name
FROM departments d, locations l, countries c
WHERE l.country_id = c.country_id
AND d.location_id = l.location_id;
```

<br>

***

### 문제 85


<br>

```
사원들의 employee_id, last_name, department_name을 출력하는데 소속부서가 없는 사원도 출력하시고, 소속사원이 없는 부서도 출력하세요. ANSI표준 조인, 오라클 전용 조인으로 만드세요.
```

<br>

UNION
```sql
SELECT e.employee_id, e.last_name, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id(+)
UNION
SELECT e.employee_id, e.last_name, d.department_name
FROM employees e, departments d
WHERE e.department_id(+) = d.department_id;
```

UNION ALL
```sql
SELECT e.employee_id, e.last_name, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id(+)
UNION ALL
SELECT null, null, d.department_name
FROM departments d
WHERE NOT EXISTS (
  SELECT 'X'
  FROM employees
  WHERE department_id = d.department_id);
```

JOIN
```sql
SELECT e.employee_id, e.last_name, d.department_name
FROM employees e FULL OUTER JOIN departments d
ON e.department_id = d.department_id;
```

<BR>

***

### 문제 86 -ROLLUP 연산자

<br>

```
1. department_id, job_id, manager_id 기준으로 총액 급여를 출력
2. department_id, job_id 기준으로 총액급여출력
3. department_id 기준으로 총액급여 출력
4. 전체 총액 급여를 출력

1,2,3,4를 한꺼번에 출력해주세요.
```

<br>

```sql
SELECT department_id, job_id, manager_id, sum(salary)
FROM employees
GROUP BY department_id, job_id, manager_id
UNION ALL 
SELECT department_id, job_id, null, sum(salary)
FROM employees
GROUP BY department_id, job_id
UNION ALL
SELECT department_id, null, null, sum(salary)
FROM employees
GROUP BY department_id
UNION ALL
SELECT null,null, null, sum(salary)
FROM employees;
```
```sql
SELECT department_id, job_id, manager_id, sum(salary)
FROM employees
GROUP BY ROLLUP(department_id, job_id, manager_id);
```

<br>

***

### 문제 87 -GROUPING SETS 연산자

<br>

```
1. department_id, manager_id 기준 급여 총합
2. department_id, job_id 기준 급여 총합
1,2를 한꺼번에 출력해주세요.
```

<br>

```sql
SELECT department_id, manager_id, null, SUM(salary)
FROM employees
GROUP BY department_id,manager_id
UNION ALL
SELECT department_id, null, job_id, SUM(salary)
FROM employees
GROUP BY department_id,job_id;
```
```sql
SELECT department_id, manager_id, job_id, SUM(salary)
FROM employees
GROUP BY GROUPING SETS((department_id,manager_id),
                       (department_id,job_id));
```

<br>

***

### 문제 88

<br>

```
년도별로 입사한 인원수, 전체 인원수를 출력해주세요

           2001          2002             2003           2004          2005            2006           2007             2008      총인원수
---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------
               1                 7                6                 10             29               24               19                11         107
```

<br>

```sql
SELECT MAX(DECODE(y,2001,cn)) "2001",
       MAX(DECODE(y,2002,cn)) "2002",
       MAX(DECODE(y,2003,cn)) "2003",
       MAX(DECODE(y,2004,cn)) "2004",
       MAX(DECODE(y,2005,cn)) "2005",
       MAX(DECODE(y,2006,cn)) "2006",
       MAX(DECODE(y,2007,cn)) "2007",
       MAX(DECODE(y,2008,cn)) "2008",
       MAX(DECODE(y,null,cn)) "총인원수"
FROM (
     SELECT TO_CHAR(hire_date,'yyyy') y, COUNT(*) cn
     FROM employees
     GROUP BY ROLLUP(TO_CHAR(hire_date,'yyyy')));
```

<br>

***

### 문제 89

<br>

```
달별 입사한 인원수, 총인원수를 출력해주세요.

           1월              2월             3월              4월              5월              6월              7월             8월              9월             10월           11월            12월       총인원수
--------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------
            14              13               17                7                6               11                7                9                  5                6                 5             7              107
```

<br>

```sql
       
SELECT SUM(DECODE(m,01,cn)) "1월",
       SUM(DECODE(m,02,cn)) "2월",
       SUM(DECODE(m,03,cn)) "3월",
       SUM(DECODE(m,04,cn)) "4월",
       SUM(DECODE(m,05,cn)) "5월",
       SUM(DECODE(m,06,cn)) "6월",
       SUM(DECODE(m,07,cn)) "7월",
       SUM(DECODE(m,08,cn)) "8월",
       SUM(DECODE(m,09,cn)) "9월",
       SUM(DECODE(m,10,cn)) "10월",
       SUM(DECODE(m,11,cn)) "11월",
       SUM(DECODE(m,12,cn)) "12월",
       SUM(DECODE(m,NULL,cn)) "총인원수"
--     MAX(CASE WHEN m IS NULL THEN cn END) "총인원수1"
FROM (
     SELECT TO_CHAR(hire_date,'mm') m, COUNT(*) cn
     FROM employees
     GROUP BY ROLLUP(TO_CHAR(hire_date,'mm')));
```
```sql
SELECT SUM(DECODE(m,'1월 ',cn)) "1월",
       SUM(DECODE(m,'2월 ',cn)) "2월",
       SUM(DECODE(m,'3월 ',cn)) "3월",
       SUM(DECODE(m,'4월 ',cn)) "4월",
       SUM(DECODE(m,'5월 ',cn)) "5월",
       SUM(DECODE(m,'6월 ',cn)) "6월",
       SUM(DECODE(m,'7월 ',cn)) "7월",
       SUM(DECODE(m,'8월 ',cn)) "8월",
       SUM(DECODE(m,'9월 ',cn)) "9월",
       SUM(DECODE(m,'10월',cn)) "10월",
       SUM(DECODE(m,'11월',cn)) "11월",
       SUM(DECODE(m,'12월',cn)) "12월",
       SUM(DECODE(m,NULL,cn)) "총인원수"
FROM (
     SELECT TO_CHAR(hire_date,'month') m, COUNT(*) cn
     FROM employees
     GROUP BY ROLLUP(TO_CHAR(hire_date,'month')));

--month을 쓸 시 공백 문자 주의
```

***

<br>

### 문제 90(~94) -USER생성/권한부여

```
새로운 user를 생성하세요.

유저이름 : insa
default tablespace : users
temporary tablespace : temp
users tablespace 사용량 : 1m
```

<br>

```sql
CREATE USER insa
IDENTIFIED BY insa
DEFAULT TABLESPACE users
TEMPORARY TABLESPACE temp
QUOTA 1m ON users;

SELECT * FROM dba_users WHERE username = 'INSA'; --user 확인
```

<br>

***

### 문제 91

<br>

```
insa 유저에게 create session, create table 시스템 권한을 부여해주세요.
```

<br>

```sql
...

GRANT CREATE SESSION TO insa;
GRANT CREATE TABLE TO insa;

--아래와 같이 한 줄에 쓸 수 있다.

GRANT CREATE SESSION, CREATE TABLE TO insa;

--잘못 부여했을 시 REVOKE CREATE TABLE FROM insa;
```

<br>

***

### 문제 92

<br>

```
insa 유저가 사용할 수 있는 users tablespace quota 값을 unlimited로 수정하세요.
```

<br>

```sql
...

ALTER USER insa
QUOTA unlimited ON users;

SELECT * FROM dba_ts_quotas; --quota값 확인
```

<br>

***

### 문제 93

<br>

```
hr 유저가 소유한 employees 테이블의 select 객체 권한을 insa 유저에게 부여해주세요.
```

<br>

```sql
...

GRANT SELECT ON hr.employees TO insa;
```

<br>

***

### 문제 94

<br>

```
hr 유저가 소유한 departments 테이블의 select 객체 권한을 insa 유저에게 부여해주세요.
```

<br>

```sql
...

GRANT SELECT ON hr.departments TO insa;

SELECT * FROM user_tab_privs WHERE grantee = 'INSA'; --권한부여 확인
```

<br>

***

### 문제 95 -테이블 생성

<br>

```
insa 유저는 테이블논리적설계.pdf에 ERD(Entity Relationship Diagram)을 확인 한후 table instance chart를  보면서 테이블을 구성하세요.
```

<br>

```sql
...

SELECT * FROM user_tab_privs; --부여받은 테이블 권한 확인

CREATE TABLE 
  DEPT(DEPT_ID NUMBER(3) CONSTRAINT DEPT_PK PRIMARY KEY,
       DEPT_NAME VARCHAR2(50) CONSTRAINT DEPT_NN NOT NULL CONSTRAINT DEPT_UK UNIQUE,
       MGR NUMBER(5));

CREATE TABLE
  EMP(ID NUMBER(5) CONSTRAINT EMP_ID_PK PRIMARY KEY,
      NAME VARCHAR2(50) CONSTRAINT EMP_NAME_NN NOT NULL,
      HIRE_DATE DATE CONSTRAINT EMP_DATE_NN NOT NULL,
      SAL NUMBER(8,2) CONSTRAINT EMP_SAL_CK CHECK(SAL>100),
      MGR NUMBER(5) CONSTRAINT EMP_MGR_FK REFERENCES EMP(ID),
      DEPT_ID NUMBER(3) CONSTRAINT EMP_DEPT_ID_FK REFERENCES DEPT(DEPT_ID));
      
SELECT * FROM user_constraints;

SELECT * FROM user_constraints; --제약조건 확인
SELECT * FROM user_cons_columns; --컬럼에 걸려있는 제약조건 확인
```

<br>

***

### 문제 96(~98) -데이터 이행(이관)

<br>

```
hr.departments 테이블의 department_id, department_name, manager_id 데이터를 insa 유저의 dept 테이블로 insert 한후 영구히 저장하세요.
```

<br>

```sql
...

INSERT INTO dept(dept_id, dept_name, mgr)
SELECT department_id, department_name, manager_id
FROM hr.departments;
COMMIT;
```

<br>

***

### 문제 97

<br>

```
hr.employees 테이블의 employee_id, last_name, hire_date, salary, manager_id, department_id 데이터를 insa 유저의 emp 테이블로 insert 한후 영구히 저장하세요.
```

<br>

```sql
...

INSERT INTO emp(id, name, hire_date, sal, mgr, dept_id)
SELECT employee_id, last_name, hire_date, salary, manager_id, department_id
FROM hr.employees;
COMMIT;
```

<br>

***

### 문제 98 -중

<br>

```
insa유저의 dept 테이블의 부서정보 중에 소속사원이 없는 부서정보를 삭제한 후 영구히 저장하세요.
```

<br>

```sql
...

DELETE FROM dept d
WHERE NOT EXISTS (
  SELECT 'X'
  FROM emp
  WHERE dept_id = d.dept_id);
COMMIT;
```

<br>

***

### 문제 99

<br>

```
사원들 중에 근무연수가 15년 이상 이면서 급여는 10000이상 급여를 받는 사원들은 emp_1테이블에 사번, 이름, 입사일, 근무연수, 급여 정보를 입력하고, 근무연수가 15년 이상 이면서 급여는 10000미만 급여를 받는 사원들은 emp_2테이블에 사번, 이름, 입사일, 근무연수, 급여 정보를 입력하세요.
```

<br>

```sql
CREATE TABLE emp_1
(id number,
name varchar2(20),
hire date,
years number(2),
sal number)
TABLESPACE users;

CREATE TABLE emp_2
(id number,
name varchar2(20),
hire date,
years number(2),
sal number)
TABLESPACE users;

INSERT FIRST
WHEN sal >= 10000 THEN
INTO emp_1(id, name, hire, years, sal)
VALUES(id,name,hire,years,sal)
ELSE
INTO emp_2(id, name, hire, years, sal)
VALUES(id,name,hire,years,sal)
SELECT employee_id id, last_name name, hire_date hire, (sysdate-hire_date)/365 years, salary sal
FROM employees
WHERE (sysdate-hire_date)/365 >= 15;

SELECT * FROM emp_1;
SELECT * FROM emp_2;
```

<br>

***

### 문제 100 (~105) DML문

<br>

```
EMPLOYEES 테이블을 복제 EMP_COPY 이름으로 복제하세요.
```

<br>

```sql
CREATE TABLE emp_copy
AS SELECT * FROM hr.employees;
```

<br>

***

### 문제 101

<br>

```
EMP_COPY테이블에 employee_id에 emp_copy_id_pk 이름으로 primary key 제약조건을 추가하세요. 
```

<br>

```sql
...

ALTER TABLE emp_copy
ADD CONSTRAINT emp_copy_id_pk PRIMARY KEY(employee_id);
```

<br>

***

### 문제 102

<br>

```
EMP_COPY 테이블에 department_name varchar2(30) 컬럼을 추가하세요.
```

<br>

```sql
...

ALTER TABLE emp_copy
ADD department_name varchar2(30);

SELECT * FROM user_constraints WHERE table_name ='EMP_COPY';
```

<br>

***

### 문제 103 -중요

<br>

```
DEPARTMENTS 테이블에 있는 department_name을 기준으로 EMP_COPY 테이블에 department_name에 값을 수정하세요.
단 UPDATE문을 이용해서 해결한 후 수정된 정보를 확인하고 ROLLBACK 하세요.
```

<br>

```sql
...

UPDATE emp_copy
SET department_name = (
  SELECT department_name
  FROM departments
  WHERE department_id = emp_copy.department_id);

ROLLBACK;
```

<br>

***

### 문제 104

<br>

```
DEPARTMENTS 테이블에 있는 department_name을 기준으로 EMP_COPY 테이블에 department_name에 값을 수정하세요.
단 MERGE문을 이용해서 해결한 후  수정된 정보를 영구히 저장하세요.
```

<br>

```sql
...

MERGE INTO emp_copy e
USING departments d
ON (e.department_id = d.department_id)
WHEN MATCHED THEN
  UPDATE SET
    e.department_name = d.department_name;
COMMIT;
```

<br>

***

### 문제 105

<br>

```
EMP_COPY 테이블에 department_name에 값을 NULL 값으로 수정하세요. 
단 MERGE문을 이용해서 해결한 후 ROLLBACK 하세요.
```

<br>

```sql
...

MERGE INTO emp_copy e 
USING departments d
ON (e.department_id = d.department_id)
WHEN MATCHED THEN
  UPDATE SET
    e.department_name = NULL;
ROLLBACK;
```

<br>

***

### 문제 106 -다중테이블 INSERT

<br>

```
사원들의 급여가 5000 미만일 경우 employee_id, salary 정보를 SPECIAL_SAL 테이블에 입력하고 
아니면 employee_id, hire_date, salary정보를 SAL_HISTORY 테이블에 입력하고 
또는  employee_id, manager_id, salary 정보를  MGR_HISTORY 테이블에 입력한다.
```

<br>

```sql
CREATE TABLE special_sal
AS 
SELECT employee_id, salary
FROM hr.employees WHERE 1=2;

CREATE TABLE sal_history
AS 
SELECT employee_id, hire_date, salary
FROM hr.employees WHERE 1=2;

CREATE TABLE mgr_history
AS 
SELECT employee_id, manager_id, salary
FROM hr.employees WHERE 1=2;

INSERT FIRST
WHEN sal < 5000 THEN
INTO special_sal(employee_id, salary)
VALUES(id, sal)
ELSE
INTO sal_history(employee_id, hire_date, salary)
VALUES(id, hire, sal)
INTO mgr_history(employee_id, manager_id, salary)
VALUES(id, mgr, sal)
SELECT employee_id id, salary sal, hire_date hire, manager_id mgr
FROM hr.employees;

SELECT * FROM special_sal;
SELECT * FROM sal_history;
SELECT * FROM mgr_history;
```

<br>

***

### 문제 107 -EXTERNAL TABLE

<br>

```
emp.csv 파일의 데이터를 분석하려고 한다. external table를 생성하세요.
```

<br>

```sql
--DBA

CREATE DIRECTORY data_dir AS 'C:\DATA\';
SELECT * FROM dba_directories;
GRANT READ, WRITE ON DIRECTORY data_dir TO hr;
```
```sql
--USER

SELECT * FROM user_tab_privs WHERE table_name = 'DATA_DIR'; --권한 부여 확인
SELECT * FROM all_directories WHERE directory_name = 'DATA_DIR'; --디렉토리 확인

CREATE TABLE emp_ext_tab
(id number,
name varchar2(30),
hire_date date,
job varchar2(20),
dept_id number)
ORGANIZATION EXTERNAL(
  TYPE oracle_loader
  DEFAULT DIRECTORY data_dir
  ACCESS PARAMETERS(
    RECORDS DELIMITED BY NEWLINE
    BADFILE 'empbad.bad'
    LOGFILE 'emplog.log'
    FIELDS TERMINATED BY ','
    MISSING FIELD VALUES ARE NULL
      (id, name, hire_date CHAR DATE_FORMAT DATE MASK "YYYYMMDD", job, dept_id)
    )
  LOCATION('emp.csv')
)
REJECT LIMIT UNLIMITED;

SELECT * FROM emp_ext_tab;
```

<br>

***

### 문제 108 -복합 뷰(INLINE VIEW)

<BR>

```
부서이름별 총액급여, 평균급여, 최고급여, 최저급여를 출력하는 query문을 작성한 후, dept_sal_vw view를 생성하세요.
```

<BR>

```sql
CREATE OR REPLACE VIEW dept_sal_vw
AS
SELECT *
FROM (
  SELECT d.department_name, e.sum_sal, e.avg_sal, e.max_sal, e.min_sal
  FROM (
    SELECT department_id, SUM(salary) sum_sal, TRUNC(AVG(salary),1) avg_sal, MAX(salary) max_sal, MIN(salary) min_sal
    FROM employees
    GROUP BY department_id) e,
  departments d
WHERE e.department_id = d.department_id);
```
```sql
--Join의 일 양을 줄이기 위해 위의 코드를 사용하는 것이 좋음

CREATE OR REPLACE VIEW dept_sal_vw
AS
SELECT d.department_name, SUM(salary) sum_sal, TRUNC(AVG(salary),1) avg_sal, MAX(salary) max_sal, MIN(salary) min_sal
FROM employees e, departments d
WHERE e.department_id = d.department_id
GROUP BY department_name;
```

<br>

***

### 문제 109 -통계수집

<br>

```
emp 테이블을 생성한 후 통계정보를 확인 한후 통계수집을 하세요.

create table emp
as select * from employees;
```

<br>

```sql
--테이블 생성
CREATE TABLE emp
AS SELECT * FROM employees;

--통계정보 확인
SELECT num_rows, blocks, avg_row_len
FROM user_tables
WHERE table_name = 'EMP';

--통계수집 권한 확인
SELECT * FROM user_tab_privs;

--통계수집
EXEC dbms_stats.gather_table_stats('hr','emp');

--통계정보 재확인
SELECT num_rows, blocks, avg_row_len
FROM user_tables
WHERE table_name = 'EMP';
```

<br>

***

### 문제 110

<br>

```
select문의 실행계획을 확인 한 후 filter를 access로 해결해 주세요.

select * from emp where employee_id = 100;
```

<br>

```sql
--실행계획 확인
EXPLAIN PLAN FOR
SELECT * FROM emp WHERE employee_id = 100;

SELECT * FROM TABLE(dbms_xplan.display(null,null,'typical'));

--제약조건으로 인덱스 설정
ALTER TABLE emp ADD CONSTRAINT emp_id_pk PRIMARY KEY(employee_id);

CREATE INDEX emp_emp_id
ON emp(employee_id);

--실행계획 재확인
EXPLAIN PLAN FOR
SELECT * FROM emp WHERE employee_id = 100;

SELECT * FROM TABLE(dbms_xplan.display(null,null,'typical'));
```

<br>

***

### 문제 111

<br>

```
select문의 실행계획을 확인 한 후 filter를 access로 해결해 주세요.

select * from emp where department_id = 10;
```

<br>

```sql
EXPLAIN PLAN FOR
SELECT * FROM emp WHERE department_id = 10;
SELECT * FROM TABLE(dbms_xplan.display(null,null,'typical'));

CREATE INDEX emp_dept_id
ON emp(department_id);

EXPLAIN PLAN FOR
SELECT * FROM emp WHERE department_id = 10;
SELECT * FROM TABLE(dbms_xplan.display(null,null,'typical'));
```

<br>

***

### 문제 112 -조합 INDEX

<br>

```
select문의 실행계획을 확인 한 후 filter를 access로 해결해 주세요.

select * from emp where last_name = 'King' and first_name = 'Steven';
```

<br>

```sql
EXPLAIN PLAN FOR
SELECT * FROM emp WHERE last_name = 'King' AND first_name = 'Steven';
SELECT * FROM TABLE(dbms_xplan.display(null,null,'typical'));

CREATE INDEX emp_name_idx
ON emp(last_name,first_name);

EXPLAIN PLAN FOR
SELECT * FROM emp WHERE last_name = 'King' AND first_name = 'Steven';
SELECT * FROM TABLE(dbms_xplan.display(null,null,'typical'));
```

<br>

***

### 문제 113(~119) -Tuning

<br>

```
emp 테이블의 통계 수집을 한 후 전체 row의 수, 사용한 block수, 한 행의 평균 byte 값을 확인 해주세요.

drop table emp  purge;

select rownum emp_id, last_name, first_name, job_id, hire_date, salary, commission_pct, email, department_id
from employees, (select rownum emp_id from dual connect by level < = 100)
order by dbms_random.value; --난수처

--조인조건 술어를 제외해서 대용량 테이블을 생성함
```

<br>

```sql
--emp table 생성
CREATE TABLE emp
AS 
select rownum emp_id, last_name, first_name, job_id, hire_date, salary, commission_pct, email, department_id
from employees, (select rownum emp_id from dual connect by level < = 100)
order by dbms_random.value; 

--통계 정보 권한 확인(dbms_stats)
SELECT * FROM user_tab_privs;

--통계 수집
EXEC dbms_stats.gather_table_stats('hr','emp')

--통계정보 확인
SELECT num_rows, blocks, avg_row_len
FROM user_tables
WHERE table_name = 'EMP';
```

<br>

***

### 문제 114

<br>

```
 hr 유저는 sql문을 수행 한 후 실제 수행한 실행계획 처리한 블록의 수를 확인하기위해서 dbms_xplan.display_cursor 사용하려고 할때 필요한 권한은 작성해 주세요.
```

<br>

```sql
GRANT SELECT ON v_$session TO hr; --session 모니터링
GRANT SELECT ON v_$sql TO hr; --sql문장을 볼 수 있는 view 권한
GRANT SELECT ON v_$sql_plan TO hr; --plan을 볼 수 있는 view 권한
GRANT SELECT ON v_$sql_plan_statistics TO hr; --통계정보 볼 수 있는 view 권한
GRANT SELECT ON v_$sql_plan_statistics_all TO hr; --모든 정보를 볼 수 있는 view 권한
```

<br>

***

### 문제 115

<br>

```
이 쿼리문장을 튜닝하기 전과 튜닝한 후를  비교해주세요.

select * from emp where emp_id = 100; 
```

<br>

```sql
--쿼리문의 실제 실행계획 확인
SELECT /*+ gather_plan_statistics */ * 
FROM emp
WHERE emp_id = 100;

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));

--튜닝
ALTER TABLE emp
ADD CONSTRAINTS emp_id_pk
PRIMARY KEY (emp_id);

SELECT ix.index_name, ix.uniqueness, ic.column_name
FROM user_indexes ix, user_ind_columns ic
WHERE ix.index_name = ic.index_name
AND ix.table_name = 'EMP';

SELECT /*+ gather_plan_statistics */ * 
FROM emp
WHERE emp_id = 100;

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));
```

<br>

***

### 문제 116

<br>

```
이 쿼리문장을 튜닝하기 전과 튜닝한 후를  비교해주세요.

SQL> select count(*) from emp where last_name = 'King';
```

<br>

```sql
--실행계획 확인
SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE last_name = 'King';
SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));

--튜닝
CREATE INDEX emp_ind_last_name
ON hr.emp(last_name);

SELECT ix.index_name, ix.uniqueness, ic.column_name
FROM user_indexes ix, user_ind_columns ic
WHERE ix.index_name = ic.index_name
AND ix.table_name = 'EMP';

SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE last_name = 'King';
SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));
```

<br>

***

### 문제 117

<br>

```
이 쿼리문장을 튜닝하기 전과 튜닝한 후를  비교해주세요.

select count(*) from emp where last_name = 'King' and first_name = 'Steven';
```

<br>

```sql
--실행계획 확인
SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE last_name = 'King' 
AND first_name = 'Steven';

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));

--튜닝
CREATE INDEX ind_name
ON hr.emp(last_name, first_name);

SELECT ix.index_name, ix.uniqueness, ic.column_name
FROM user_indexes ix, user_ind_columns ic
WHERE ix.index_name = ic.index_name
AND ix.table_name = 'EMP';

SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE last_name = 'King'
AND first_name = 'Steven';

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));
```

<br>

***

### 문제 118

<br>

```
emp 테이블에 있는 데이터 중에 2001년도 입사한 사원들의 인원수를 조회하는 쿼리문장을 만드시고 성능이 나도록 구성하세요.
```

<br>

```sql
--실행계획 확인
SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE hire_date >=  to_date('2001-01-01','yyyy-mm-dd')
AND hire_date < to_date('2002-01-01','yyyy-mm-dd');

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));

--튜닝
CREATE INDEX emp_ind_date ON hr.emp(hire_date);

SELECT ix.index_name, ix.uniqueness, ic.column_name
FROM user_indexes ix, user_ind_columns ic
WHERE ix.index_name = ic.index_name
AND ix.table_name = 'EMP';

SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE hire_date >=  to_date('2001-01-01','yyyy-mm-dd')
AND hire_date < to_date('2002-01-01','yyyy-mm-dd');


SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));
```

<br>

***

### 문제 119

<br>

```
emp 테이블에 있는 데이터 중에 2003년도 입사한 사원들 중에 10번 부서 인원수를 조회하는 쿼리문장을 만드시고 성능이 나도록 구성하세요.
```

<br>

```sql
--실행계획 확인
SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE hire_date >= to_date('2003-01-01','yyyy-mm-dd')
AND hire_date < to_date('2004-01-01','yyyy-mm-dd')
AND department_id = 10;

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last')); 

--조합인덱스 설정
DROP INDEX emp_ind_date;

CREATE INDEX emp_ind_dept_date ON hr.emp(department_id, hire_date);

SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE hire_date >= to_date('2003-01-01','yyyy-mm-dd')
AND hire_date < to_date('2004-01-01','yyyy-mm-dd')
AND department_id = 10;

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));
```

<br>

***

### 문제 120 -조합인덱스/단일인덱스

<br>

```
아래 쿼리문장을 문제118번에서 만든 인덱스를 사용할때와  문제119번에 만든 인덱스를 사용할때를 비교하세요.


select count(*) from emp where hire_date >= to_date('2001-01-01','yyyy-mm-dd') and hire_date < to_date('2002-01-01','yyyy-mm-dd');
```

<br>

```sql
--118번의 인덱스 사용 (single index)
SELECT * FROM user_ind_columns WHERE table_name = 'EMP';

DROP INDEX emp_ind_dept_date;

CREATE INDEX emp_ind_date ON hr.emp(hire_date);

SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE hire_date >= to_date('2001-01-01','yyyy-mm-dd') 
AND hire_date < to_date('2002-01-01','yyyy-mm-dd');

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));


/*
>결과

SQL_ID  dvajzm0ud78g1, child number 0
-------------------------------------
SELECT /*+ gather_plan_statistics */ COUNT(*)  FROM emp  WHERE 
hire_date >= to_date('2001-01-01','yyyy-mm-dd')   AND hire_date < 
to_date('2002-01-01','yyyy-mm-dd')
 
Plan hash value: 904028534
 
--------------------------------------------------------------------------------------------
| Id  | Operation         | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |              |      1 |        |      1 |00:00:00.01 |       2 |
|   1 |  SORT AGGREGATE   |              |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  2 |   INDEX RANGE SCAN| EMP_IND_DATE |      1 |   1423 |    100 |00:00:00.01 |       2 |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
*/



--119번의 인덱스 사용(조합 index)
--hint를 사용하지 않았을 때,

DROP INDEX emp_ind_date;

CREATE INDEX emp_ind_dept_date ON hr.emp(department_id,hire_date);

SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE hire_date >= to_date('2001-01-01','yyyy-mm-dd') 
AND hire_date < to_date('2002-01-01','yyyy-mm-dd');

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));

/*
>결과

SQL_ID  dvajzm0ud78g1, child number 0
-------------------------------------
SELECT /*+ gather_plan_statistics */ COUNT(*)  FROM emp  WHERE 
hire_date >= to_date('2001-01-01','yyyy-mm-dd')   AND hire_date < 
to_date('2002-01-01','yyyy-mm-dd')
 
Plan hash value: 2733431210
 
-----------------------------------------------------------------------------------------------------
| Id  | Operation             | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |                   |      1 |        |      1 |00:00:00.01 |      38 |
|   1 |  SORT AGGREGATE       |                   |      1 |      1 |      1 |00:00:00.01 |      38 |
|*  2 |   INDEX FAST FULL SCAN| EMP_IND_DEPT_DATE |      1 |   1423 |    100 |00:00:00.01 |      38 |
-----------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
*/


--Hint를 사용하였을 때 (skip scanning)

SELECT /*+ gather_plan_statistics 
                    index_ss(e emp_ind_dept_date) */ COUNT(*)
FROM emp e
WHERE hire_date >= to_date('2001-01-01','yyyy-mm-dd') 
AND hire_date < to_date('2002-01-01','yyyy-mm-dd');

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));

/*
SQL_ID  4fbw83d4y36d4, child number 0
-------------------------------------
SELECT /*+ gather_plan_statistics                       index_ss(e 
emp_ind_dept_date) */ COUNT(*)  FROM emp e  WHERE hire_date >= 
to_date('2001-01-01','yyyy-mm-dd')   AND hire_date < 
to_date('2002-01-01','yyyy-mm-dd')
 
Plan hash value: 3272440797
 
------------------------------------------------------------------------------------------------
| Id  | Operation        | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |                   |      1 |        |      1 |00:00:00.01 |      10 |
|   1 |  SORT AGGREGATE  |                   |      1 |      1 |      1 |00:00:00.01 |      10 |
|*  2 |   INDEX SKIP SCAN| EMP_IND_DEPT_DATE |      1 |   1423 |    100 |00:00:00.01 |      10 |
------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("HIRE_DATE">=TO_DATE(' 2001-01-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') 
              AND "HIRE_DATE"<TO_DATE(' 2002-01-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
       filter(("HIRE_DATE"<TO_DATE(' 2002-01-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') 
              AND "HIRE_DATE">=TO_DATE(' 2001-01-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss')))
*/
```

<br>

***

### 문제 121 -문장재구성 튜닝

<br>

```
쿼리문장을 확인하시고 튜닝하세요.

SQL> select count(*) from emp where substr(last_name,1,2) = 'Ba';
```

<br>

```sql
--실행 계획 확인
SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE substr(last_name,1,2) = 'Ba';

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));

/*
>결과

SQL_ID  9d6zr16kdxh34, child number 1
-------------------------------------
SELECT /*+ gather_plan_statistics */ COUNT(*) FROM emp WHERE 
substr(last_name,1,2) = 'Ba'
 
Plan hash value: 3476320319
 
-----------------------------------------------------------------------------------------------------
| Id  | Operation             | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |                   |      1 |        |      1 |00:00:00.01 |      32 |
|   1 |  SORT AGGREGATE       |                   |      1 |      1 |      1 |00:00:00.01 |      32 |
|*  2 |   INDEX FAST FULL SCAN| EMP_IND_LAST_NAME |      1 |    107 |    400 |00:00:00.01 |      32 |
-----------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
*/


--튜닝

SELECT /*+ gather_plan_statistics */ COUNT(*)
FROM emp
WHERE last_name like 'Ba%';

SELECT * FROM table(dbms_xplan.display_cursor(null,null,'allstats last'));

/*
>결과

SQL_ID  5fp1wcn6ffzmy, child number 0
-------------------------------------
SELECT /*+ gather_plan_statistics */ COUNT(*) FROM emp WHERE last_name 
like 'Ba%'
 
Plan hash value: 112362506
 
-------------------------------------------------------------------------------------------------
| Id  | Operation         | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |                   |      1 |        |      1 |00:00:00.01 |       3 |
|   1 |  SORT AGGREGATE   |                   |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  2 |   INDEX RANGE SCAN| EMP_IND_LAST_NAME |      1 |    107 |    400 |00:00:00.01 |       3 |
-------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("LAST_NAME" LIKE 'Ba%')
       filter("LAST_NAME" LIKE 'Ba%')
 */
```

<br>

***

### 문제 122

<br>

```
테이블 통계 수집을 하시고 컬럼 정보를 확인 하세요.

TABLE_NAME                       NUM_ROWS     BLOCKS AVG_ROW_LEN LAST_ANAL
------------------------------ ---------- ---------- ----------- ---------
LOC
EMP
DEPT
```

<br>

```sql
CREATE TABLE emp AS SELECT * FROM employees;
CREATE TABLE dept AS SELECT * FROM departments;
CREATE TABLE loc AS SELECT * FROM locations;

EXEC dbms_stats.gather_table_stats('hr','emp')
EXEC dbms_stats.gather_table_stats('hr','dept')
EXEC dbms_stats.gather_table_stats('hr','loc')

SELECT table_name, num_rows, blocks, avg_row_len, last_analyzed
FROM user_tables
WHERE table_name IN ('EMP','DEPT','LOC');
```

<br>

***

### 문제 123 -NESTED LOOP

<br>

```
SQL문장의 실행계획을 확인 한 후 nested loop join 으로 튜닝하세요.

SQL> select e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and e.employee_id = 100;
```

<br>

```sql
--데이터가 적은 양일 때 HASH/MERGE JOIN이면 무조건 튜닝 대상(HASH/MERGE JOIN은 많은 메모리 사용)

SELECT /*+ leading(e,d,l) use_nl(d) use_nl(l) */ e.last_name, e.job_id, d.department_name, l.city
FROM emp e, dept d, loc l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND e.employee_id = 100;

>결과
--------------------------------------------------------------------------------------
| Id  | Operation           | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |      |      1 |        |      1 |00:00:00.01 |      10 |
|   1 |  NESTED LOOPS       |      |      1 |      1 |      1 |00:00:00.01 |      10 |
|   2 |   NESTED LOOPS      |      |      1 |      1 |      1 |00:00:00.01 |       7 |
|*  3 |    TABLE ACCESS FULL| EMP  |      1 |      1 |      1 |00:00:00.01 |       4 |
|*  4 |    TABLE ACCESS FULL| DEPT |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  5 |   TABLE ACCESS FULL | LOC  |      1 |      1 |      1 |00:00:00.01 |       3 |
--------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter("E"."EMPLOYEE_ID"=100)
   4 - filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   5 - filter("D"."LOCATION_ID"="L"."LOCATION_ID")


--nested loop를 hint를 써서 적용시켰다. filter를 access로 바꾸어서 튜닝을 하면 좋다고 판단되어서 index를 걸어 access로 유도해보자. index는 pk조건으로 걸었다.

--제약조건 확인
SELECT a.constraint_name, b.column_name, a.constraint_type, a.search_condition, a.r_constraint_name,a.index_name
FROM user_constraints a, user_cons_columns b
WHERE a.constraint_name = b.constraint_name
AND a.table_name IN ('EMP','DEPT','LOC');

--인덱스 확인
SELECT ix.index_name, ix.uniqueness, ic.column_name
FROM user_indexes ix, user_ind_columns ic
WHERE ix.index_name = ic.index_name
AND ix.table_name IN ('EMP','DEPT','LOC');

--PRIMARY KEY 설정
ALTER TABLE emp ADD CONSTRAINTS emp_pk PRIMARY KEY (employee_id);
ALTER TABLE dept ADD CONSTRAINTS dept_pk PRIMARY KEY (department_id);
ALTER TABLE loc ADD CONSTRAINTS loc_pk PRIMARY KEY (location_id);

--쿼리 수행
SELECT /*+ leading(e,d,l) use_nl(d) use_nl(l) */ e.last_name, e.job_id, d.department_name, l.city
FROM emp e, dept d, loc l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND e.employee_id = 100;

>결과
---------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name    | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
---------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |         |      1 |        |      1 |00:00:00.01 |       6 |
|   1 |  NESTED LOOPS                 |         |      1 |      1 |      1 |00:00:00.01 |       6 |
|   2 |   NESTED LOOPS                |         |      1 |      1 |      1 |00:00:00.01 |       4 |
|   3 |    TABLE ACCESS BY INDEX ROWID| EMP     |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  4 |     INDEX UNIQUE SCAN         | EMP_PK  |      1 |      1 |      1 |00:00:00.01 |       1 |
|   5 |    TABLE ACCESS BY INDEX ROWID| DEPT    |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  6 |     INDEX UNIQUE SCAN         | DEPT_PK |      1 |      1 |      1 |00:00:00.01 |       1 |
|   7 |   TABLE ACCESS BY INDEX ROWID | LOC     |      1 |      1 |      1 |00:00:00.01 |       2 |
|*  8 |    INDEX UNIQUE SCAN          | LOC_PK  |      1 |      1 |      1 |00:00:00.01 |       1 |
---------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access("E"."EMPLOYEE_ID"=100)
   6 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   8 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
```

<br>

***

### 문제 124

<br>

```
SQL문장의 실행계획을 확인 한 후 NESTED LOOP JOIN으로 튜닝하세요.

SQL> select e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.city = 'Seattle'; 
```

<br>

```sql
--Seattle의 조건이 있으니 join 순서를 loc부터 설정하자

SELECT /*+ leading(l,d,e) use_nl(d) use_nl(e) */ e.last_name, e.job_id, d.department_name, l.city
FROM emp e, dept d, loc l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Seattle'; 

>결과
--------------------------------------------------------------------------------------
| Id  | Operation           | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |      |      1 |        |     18 |00:00:00.01 |      72 |
|   1 |  NESTED LOOPS       |      |      1 |     15 |     18 |00:00:00.01 |      72 |
|   2 |   NESTED LOOPS      |      |      1 |      4 |     21 |00:00:00.01 |       7 |
|*  3 |    TABLE ACCESS FULL| LOC  |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  4 |    TABLE ACCESS FULL| DEPT |      1 |      4 |     21 |00:00:00.01 |       4 |
|*  5 |   TABLE ACCESS FULL | EMP  |     21 |      4 |     18 |00:00:00.01 |      65 |
--------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter("L"."CITY"='Seattle')
   4 - filter("D"."LOCATION_ID"="L"."LOCATION_ID")
   5 - filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   

--filter 조건을 access로 바꾸기 위해 index를 설정해보자

--inner에 index 설정
CREATE INDEX loc_city_ind ON loc(city);
CREATE INDEX dept_loc_id_ix ON dept(location_id);
CREATE INDEX emp_dept_id_ix ON emp(department_id);

--index 확인
SELECT ix.index_name, ix.uniqueness, ic.column_name, ic.column_position
FROM user_indexes ix, user_ind_columns ic
WHERE ix.index_name = ic.index_name
AND ix.table_name IN ('EMP','DEPT','LOC');

SELECT /*+ leading(l,d,e) use_nl(d) use_nl(e) */ e.last_name, e.job_id, d.department_name, l.city
FROM emp e, dept d, loc l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Seattle'; 

>결과
-----------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name           | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                |      1 |        |     18 |00:00:00.01 |      18 |
|   1 |  NESTED LOOPS                  |                |      1 |        |     18 |00:00:00.01 |      18 |
|   2 |   NESTED LOOPS                 |                |      1 |     15 |     18 |00:00:00.01 |      15 |
|   3 |    NESTED LOOPS                |                |      1 |      4 |     21 |00:00:00.01 |       9 |
|   4 |     TABLE ACCESS BY INDEX ROWID| LOC            |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  5 |      INDEX RANGE SCAN          | LOC_CITY_IND   |      1 |      1 |      1 |00:00:00.01 |       2 |
|   6 |     TABLE ACCESS BY INDEX ROWID| DEPT           |      1 |      4 |     21 |00:00:00.01 |       6 |
|*  7 |      INDEX RANGE SCAN          | DEPT_LOC_ID_IX |      1 |      4 |     21 |00:00:00.01 |       3 |
|*  8 |    INDEX RANGE SCAN            | EMP_DEPT_ID_IX |     21 |     10 |     18 |00:00:00.01 |       6 |
|   9 |   TABLE ACCESS BY INDEX ROWID  | EMP            |     18 |      4 |     18 |00:00:00.01 |       3 |
-----------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("L"."CITY"='Seattle')
   7 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   8 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   
--위에서 마지막 Nested loop는 batch i/o를 발생시켰다
```

<br>

***

### 문제 125 -중요

<br>

```
SQL문장의 실행계획을 확인 한 후 튜닝하세요.

select  e.last_name, e.job_id, d.department_name, l.city
from emp e, dept d, loc l
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.city = 'Seattle'
and e.job_id = 'AD_VP';
```

<br>

```sql
SELECT e.last_name, e.job_id, d.department_name, l.city
FROM emp e, dept d, loc l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Seattle'
AND e.job_id = 'AD_VP';  

>결과

-----------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name           | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                |      1 |        |      2 |00:00:00.01 |      16 |
|   1 |  NESTED LOOPS                  |                |      1 |        |      2 |00:00:00.01 |      16 |
|   2 |   NESTED LOOPS                 |                |      1 |      1 |     18 |00:00:00.01 |      12 |
|   3 |    NESTED LOOPS                |                |      1 |      4 |     21 |00:00:00.01 |       7 |
|   4 |     TABLE ACCESS BY INDEX ROWID| LOC            |      1 |      1 |      1 |00:00:00.01 |       3 |
|*  5 |      INDEX RANGE SCAN          | LOC_CITY_IND   |      1 |      1 |      1 |00:00:00.01 |       2 |
|   6 |     TABLE ACCESS BY INDEX ROWID| DEPT           |      1 |      4 |     21 |00:00:00.01 |       4 |
|*  7 |      INDEX RANGE SCAN          | DEPT_LOC_ID_IX |      1 |      4 |     21 |00:00:00.01 |       2 |
|*  8 |    INDEX RANGE SCAN            | EMP_DEPT_ID_IX |     21 |     10 |     18 |00:00:00.01 |       5 |
|*  9 |   TABLE ACCESS BY INDEX ROWID  | EMP            |     18 |      1 |      2 |00:00:00.01 |       4 |
-----------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("L"."CITY"='Seattle')
   7 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   8 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   9 - filter("E"."JOB_ID"='AD_VP')

--비조인조건 술어를 확인해서 적은 양의 데이터를 가진 테이블을 outer로 사용하게 하자
--즉, driving 할 테이블을 선정하기 위해 seattle과 AD_VP를 확인한다.

SELECT * 
FROM emp e, dept d 
WHERE e.department_id = d.department_id 
AND e.job_id = 'AD_VP';
 
SELECT * 
FROM dept d, loc l 
WHERE d.location_id = l.location_id 
AND l.city = 'Seattle';
 
SELECT /*+ leading(e,d,l) use_nl(d) use_nl(l) */ e.last_name, e.job_id, d.department_name, l.city
FROM emp e, dept d, loc l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Seattle'
AND e.job_id = 'AD_VP';

>결과

---------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
---------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |              |      1 |        |      2 |00:00:00.01 |      13 |
|   1 |  NESTED LOOPS                  |              |      1 |        |      2 |00:00:00.01 |      13 |
|   2 |   NESTED LOOPS                 |              |      1 |      1 |      2 |00:00:00.01 |      11 |
|   3 |    NESTED LOOPS                |              |      1 |      6 |      2 |00:00:00.01 |       8 |
|*  4 |     TABLE ACCESS FULL          | EMP          |      1 |      6 |      2 |00:00:00.01 |       4 |
|   5 |     TABLE ACCESS BY INDEX ROWID| DEPT         |      2 |      1 |      2 |00:00:00.01 |       4 |
|*  6 |      INDEX UNIQUE SCAN         | DEPT_PK      |      2 |      1 |      2 |00:00:00.01 |       2 |
|*  7 |    INDEX RANGE SCAN            | LOC_CITY_IND |      2 |      1 |      2 |00:00:00.01 |       3 |
|*  8 |   TABLE ACCESS BY INDEX ROWID  | LOC          |      2 |      1 |      2 |00:00:00.01 |       2 |
---------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - filter("E"."JOB_ID"='AD_VP')
   6 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   7 - access("L"."CITY"='Seattle')
   8 - filter("D"."LOCATION_ID"="L"."LOCATION_ID")
   
   
--인덱스를 걸어 access로 풀리게 하자.

CREATE INDEX emp_job_id_ix ON emp(job_id);

SELECT /*+ leading(e,d,l) use_nl(d) use_nl(l) */ e.last_name, e.job_id, d.department_name, l.city
FROM emp e, dept d, loc l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Seattle'
AND e.job_id = 'AD_VP'; 

>결과

----------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name          | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |               |      1 |        |      2 |00:00:00.01 |      13 |
|   1 |  NESTED LOOPS                  |               |      1 |        |      2 |00:00:00.01 |      13 |
|   2 |   NESTED LOOPS                 |               |      1 |      1 |      2 |00:00:00.01 |      11 |
|   3 |    NESTED LOOPS                |               |      1 |      6 |      2 |00:00:00.01 |       8 |
|   4 |     TABLE ACCESS BY INDEX ROWID| EMP           |      1 |      6 |      2 |00:00:00.01 |       4 |
|*  5 |      INDEX RANGE SCAN          | EMP_JOB_ID_IX |      1 |      6 |      2 |00:00:00.01 |       2 |
|   6 |     TABLE ACCESS BY INDEX ROWID| DEPT          |      2 |      1 |      2 |00:00:00.01 |       4 |
|*  7 |      INDEX UNIQUE SCAN         | DEPT_PK       |      2 |      1 |      2 |00:00:00.01 |       2 |
|*  8 |    INDEX RANGE SCAN            | LOC_CITY_IND  |      2 |      1 |      2 |00:00:00.01 |       3 |
|*  9 |   TABLE ACCESS BY INDEX ROWID  | LOC           |      2 |      1 |      2 |00:00:00.01 |       2 |
----------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("E"."JOB_ID"='AD_VP')
   7 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   8 - access("L"."CITY"='Seattle')
   9 - filter("D"."LOCATION_ID"="L"."LOCATION_ID")

--8번에서 조인조건인 location_id가 아니라 city로 연결되어 있다. outer에서 inner로 가는 방법을 고쳐주자

SELECT /*+ leading(e ,d, l) use_nl(d) use_nl_with_index(l loc1_id_pk) */ --use_nl_with_index 힌트 사용
e.last_name, e.job_id, d.department_name, l.city
FROM emp e, dept d, loc l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Seattle'
AND e.job_id = 'AD_VP';  

>결과

----------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name          | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |               |      1 |        |      2 |00:00:00.01 |      12 |
|   1 |  NESTED LOOPS                  |               |      1 |        |      2 |00:00:00.01 |      12 |
|   2 |   NESTED LOOPS                 |               |      1 |      1 |      2 |00:00:00.01 |      10 |
|   3 |    NESTED LOOPS                |               |      1 |      6 |      2 |00:00:00.01 |       8 |
|   4 |     TABLE ACCESS BY INDEX ROWID| EMP           |      1 |      6 |      2 |00:00:00.01 |       4 |
|*  5 |      INDEX RANGE SCAN          | EMP_JOB_ID_IX |      1 |      6 |      2 |00:00:00.01 |       2 |
|   6 |     TABLE ACCESS BY INDEX ROWID| DEPT          |      2 |      1 |      2 |00:00:00.01 |       4 |
|*  7 |      INDEX UNIQUE SCAN         | DEPT_PK       |      2 |      1 |      2 |00:00:00.01 |       2 |
|*  8 |    INDEX UNIQUE SCAN           | LOC_PK        |      2 |      1 |      2 |00:00:00.01 |       2 |
|*  9 |   TABLE ACCESS BY INDEX ROWID  | LOC           |      2 |      1 |      2 |00:00:00.01 |       2 |
----------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("E"."JOB_ID"='AD_VP')
   7 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   8 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   9 - filter("L"."CITY"='Seattle')
   
   
--location_id로 access했지만 city가 filter로 풀려 조합인덱스를 사용하여 access로 바꾸어 준다.

CREATE INDEX loc_id_city_ix ON loc(location_id, city);

SELECT /*+ leading(e ,d, l) use_nl(d) use_nl(l) */ --조합인덱스를 사용했기에 조합인덱스로 range scan하게 한다.
e.last_name, e.job_id, d.department_name, l.city
FROM emp e, dept d, loc l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Seattle'
AND e.job_id = 'AD_VP'; 


>결과

----------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name           | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                |      1 |        |      2 |00:00:00.01 |      11 |
|   1 |  NESTED LOOPS                 |                |      1 |      1 |      2 |00:00:00.01 |      11 |
|   2 |   NESTED LOOPS                |                |      1 |      6 |      2 |00:00:00.01 |       8 |
|   3 |    TABLE ACCESS BY INDEX ROWID| EMP            |      1 |      6 |      2 |00:00:00.01 |       4 |
|*  4 |     INDEX RANGE SCAN          | EMP_JOB_ID_IX  |      1 |      6 |      2 |00:00:00.01 |       2 |
|   5 |    TABLE ACCESS BY INDEX ROWID| DEPT           |      2 |      1 |      2 |00:00:00.01 |       4 |
|*  6 |     INDEX UNIQUE SCAN         | DEPT_PK        |      2 |      1 |      2 |00:00:00.01 |       2 |
|*  7 |   INDEX RANGE SCAN            | LOC_ID_CITY_IX |      2 |      1 |      2 |00:00:00.01 |       3 |
----------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access("E"."JOB_ID"='AD_VP')
   6 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   7 - access("D"."LOCATION_ID"="L"."LOCATION_ID" AND "L"."CITY"='Seattle')

```

<br>

***

### 문제 126 -sort merge join

<br>

```
SQL문장의 실행계획을 확인 한 후 sort merge join의 방법으로 튜닝하세요.

SQL> select /*+ leading(l,d,e) use_nl(d) use_nl(e)  */ e.last_name, e.first_name, e.salary, e.job_id, d.department_name, l.city, l.street_address
from employees e, departments d, locations l
where d.department_id = e.department_id
and d.location_id = l.location_id;
```

<br>

```sql
--실행계획 확인
EXEC dbms_stats.gather_table_stats('hr','employees');
EXEC dbms_stats.gather_table_stats('hr','departments');
EXEC dbms_stats.gather_table_stats('hr','locations');

ALTER SESSION SET statistics_level=all;

SELECT /*+ leading(l,d,e) use_nl(d) use_nl(e)  */ e.last_name, e.first_name, e.salary, e.job_id, d.department_name, l.city, l.street_address
FROM employees e, departments d, locations l
WHERE d.department_id = e.department_id
AND d.location_id = l.location_id;


>결과

--------------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                   |      1 |        |    106 |00:00:00.01 |   54 |
|   1 |  NESTED LOOPS                  |                   |      1 |        |    106 |00:00:00.01 |   54 |
|   2 |   NESTED LOOPS                 |                   |      1 |    106 |    106 |00:00:00.01 |   41 |
|   3 |    NESTED LOOPS                |                   |      1 |     27 |     27 |00:00:00.01 |   27 |
|   4 |     TABLE ACCESS FULL          | LOCATIONS         |      1 |     23 |     23 |00:00:00.01 |   11 |
|   5 |     TABLE ACCESS BY INDEX ROWID| DEPARTMENTS       |     23 |      1 |     27 |00:00:00.01 |   16 |
|*  6 |      INDEX RANGE SCAN          | DEPT_LOCATION_IX  |     23 |      4 |     27 |00:00:00.01 |   11 |
|*  7 |    INDEX RANGE SCAN            | EMP_DEPARTMENT_IX |     27 |     10 |    106 |00:00:00.01 |   14 |
|   8 |   TABLE ACCESS BY INDEX ROWID  | EMPLOYEES         |    106 |      4 |    106 |00:00:00.01 |   13 |
--------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   6 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   7 - access("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
   
--4번 full scan 이유: SELECT에서 city와 street address 정보를 들고와야하기 때문에 index scan보다 full이 더 효율적이라 볼 수 있음

--그럼 batch i/o가 발생했고 작은 table이지만 buffer가 많이 발생했으니 sort merge join으로 튜닝시켜보자.

SELECT /*+ leading(l,d,e) use_merge(d) use_merge(e)  */  e.last_name, e.first_name, e.salary, e.job_id, d.department_name, l.city, l.street_address
FROM employees e, departments d, locations l
WHERE d.department_id = e.department_id
AND d.location_id = l.location_id;


>결과

-----------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
-----------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |             |      1 |        |    106 |00:00:00.01 |      14 |       |       |          |
|   1 |  MERGE JOIN                    |             |      1 |    106 |    106 |00:00:00.01 |      14 |       |       |          |
|   2 |   SORT JOIN                    |             |      1 |     27 |     27 |00:00:00.01 |       8 |  4096 |  4096 | 4096  (0)| 
|   3 |    MERGE JOIN                  |             |      1 |     27 |     27 |00:00:00.01 |       8 |       |       |          |
|   4 |     TABLE ACCESS BY INDEX ROWID| LOCATIONS   |      1 |     23 |     19 |00:00:00.01 |       2 |       |       |          |
|   5 |      INDEX FULL SCAN           | LOC_ID_PK   |      1 |     23 |     19 |00:00:00.01 |       1 |       |       |          |
|*  6 |     SORT JOIN                  |             |     19 |     27 |     27 |00:00:00.01 |       6 |  2048 |  2048 | 2048  (0)| 
|   7 |      TABLE ACCESS FULL         | DEPARTMENTS |      1 |     27 |     27 |00:00:00.01 |       6 |       |       |          | 
|*  8 |   SORT JOIN                    |             |     27 |    107 |    106 |00:00:00.01 |       6 | 18432 | 18432 |16384  (0)| 
|   9 |    TABLE ACCESS FULL           | EMPLOYEES   |      1 |    107 |    107 |00:00:00.01 |       6 |       |       |          |
-----------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   6 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
       filter("D"."LOCATION_ID"="L"."LOCATION_ID")
   8 - access("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
       filter("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")

/*
2번: department_id로 정렬
6번: location_id로 정렬
7번: RANDOM I/O때문에 index타는게 좋다(27번 반복해야해서)
8번: department_id로 정렬

질문
5번의 A-rows가 23건 나와야 하는데 19건이 나왔다. 그 이유는 통계수집결과로 d.location_id와 l.location.id의 최소/최대값의 범위를 비교하여 필요없는 값을 들고오지 않았을 것이다.
*/
```

<br>

***

### 문제 127

<br>

```
SQL문장의 실행계획을 nested loop join, sort merge join, hash join 방법으로 비교하세요.

SQL> select e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
from employees e, departments d, locations l, countries c, regions r
where e.department_id = d.department_id
and d.location_id = l.location_id
and l.country_id = c.country_id
and r.region_id = c.region_id; 
```

<br>

사전 작업
```sql
SELECT e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
FROM employees e, departments d, locations l, countries c, regions r
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.country_id = c.country_id
AND r.region_id = c.region_id; 



>결과

-----------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name             | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
-----------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |                  |      1 |        |    106 |00:00:00.01 |   31 |          |       |          |
|*  1 |  HASH JOIN                      |                  |      1 |    106 |    106 |00:00:00.01 |   31 |      792K|   792K| 1231K (0)|
|*  2 |   HASH JOIN                     |                  |      1 |     27 |     27 |00:00:00.01 |   18 |      799K|   799K|  515K (0)|
|   3 |    NESTED LOOPS                 |                  |      1 |     27 |     27 |00:00:00.01 |   12 |          |       |          |
|   4 |     MERGE JOIN                  |                  |      1 |     27 |     27 |00:00:00.01 |    8 |          |       |          |
|   5 |      TABLE ACCESS BY INDEX ROWID| DEPARTMENTS      |      1 |     27 |     27 |00:00:00.01 |    2 |          |       |          |
|   6 |       INDEX FULL SCAN           | DEPT_LOCATION_IX |      1 |     27 |     27 |00:00:00.01 |    1 |          |       |          |
|*  7 |      SORT JOIN                  |                  |     27 |     23 |     27 |00:00:00.01 |    6 |     2048 |  2048 | 2048  (0)|
|   8 |       TABLE ACCESS FULL         | LOCATIONS        |      1 |     23 |     23 |00:00:00.01 |    6 |          |       |          |
|*  9 |     INDEX UNIQUE SCAN           | COUNTRY_C_ID_PK  |     27 |      1 |     27 |00:00:00.01 |    4 |          |       |          |
|  10 |    TABLE ACCESS FULL            | REGIONS          |      1 |      4 |      4 |00:00:00.01 |    6 |          |       |          |
|  11 |   TABLE ACCESS FULL             | EMPLOYEES        |      1 |    107 |    107 |00:00:00.01 |   13 |          |       |          |
-----------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   2 - access("R"."REGION_ID"="C"."REGION_ID")
   7 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
       filter("D"."LOCATION_ID"="L"."LOCATION_ID")
   9 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
   
   
--INDEX 확인
SELECT ix.table_name, ix.index_type, ix.uniqueness, ic.column_name, ic.index_name
FROM user_indexes ix, user_ind_columns ic
WHERE ix.table_name IN ('EMPLOYEES','DEPARTMENTS','LOCATIONS','COUNTRIES','REGIONS')
AND ix.index_name = ic.index_name;
--index_type을 보니 COUNTRIES는 table organizated table임을 알 수 있다.


--table 통계 정보 확인
SELECT table_name, num_rows, blocks, avg_row_len
FROM user_tables
WHERE table_name IN ('EMPLOYEES','DEPARTMENTS','LOCATIONS','COUNTRIES','REGIONS');
```

<br>

Nested loop join
```sql
SELECT /*+ leading(r,c,l,d,e) use_nl(c) use_nl(l) use_nl(d) use_nl(e) */ e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
FROM employees e, departments d, locations l, countries c, regions r
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.country_id = c.country_id
AND r.region_id = c.region_id; 

>결과

------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |                   |      1 |        |    106 |00:00:00.01 |      82 |      3 |
|   1 |  NESTED LOOPS                   |                   |      1 |        |    106 |00:00:00.01 |      82 |      3 |
|   2 |   NESTED LOOPS                  |                   |      1 |    106 |    106 |00:00:00.01 |      68 |      3 |
|   3 |    NESTED LOOPS                 |                   |      1 |     27 |     27 |00:00:00.01 |      54 |      2 |
|   4 |     NESTED LOOPS                |                   |      1 |     23 |     23 |00:00:00.01 |      37 |      2 |
|   5 |      NESTED LOOPS               |                   |      1 |     25 |     25 |00:00:00.01 |      23 |      1 |
|   6 |       TABLE ACCESS FULL         | REGIONS           |      1 |      4 |      4 |00:00:00.01 |       8 |      0 | 
|*  7 |       INDEX FAST FULL SCAN      | COUNTRY_C_ID_PK   |      4 |      6 |     25 |00:00:00.01 |      15 |      1 |
|   8 |      TABLE ACCESS BY INDEX ROWID| LOCATIONS         |     25 |      1 |     23 |00:00:00.01 |      14 |      1 |
|*  9 |       INDEX RANGE SCAN          | LOC_COUNTRY_IX    |     25 |      2 |     23 |00:00:00.01 |       9 |      1 |
|  10 |     TABLE ACCESS BY INDEX ROWID | DEPARTMENTS       |     23 |      1 |     27 |00:00:00.01 |      17 |      0 |
|* 11 |      INDEX RANGE SCAN           | DEPT_LOCATION_IX  |     23 |      4 |     27 |00:00:00.01 |      11 |      0 |
|* 12 |    INDEX RANGE SCAN             | EMP_DEPARTMENT_IX |     27 |     10 |    106 |00:00:00.01 |      14 |      1 |
|  13 |   TABLE ACCESS BY INDEX ROWID   | EMPLOYEES         |    106 |      4 |    106 |00:00:00.01 |      14 |      0 |
------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   7 - filter("R"."REGION_ID"="C"."REGION_ID")
   9 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
  11 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
  12 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")


8번: 4개의 ROWS를 찾는데 BUFFER는 8개 발생->MULTIBLOCK I/O는 EXTENT단위로 BLOCK이 올라올 수 있으니 8개의 BLOCK을 FULL SCAN했을 것이다.  
12번: 13번이랑 순서가 바뀌었다. batch i/o. single block i/o 대신 multiblock i/o를 유발하여 buffer를 줄임



--운반단위를 조정해보자

set arraysize 1000

SELECT /*+ leading(r,c,l,d,e) use_nl(c) use_nl(l) use_nl(d) use_nl(e) */ e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
FROM employees e, departments d, locations l, countries c, regions r
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.country_id = c.country_id
AND r.region_id = c.region_id; 

---------------------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name              | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
---------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |                   |      1 |        |    106 |00:00:00.01 |      45 |
|   1 |  NESTED LOOPS                   |                   |      1 |        |    106 |00:00:00.01 |      45 |
|   2 |   NESTED LOOPS                  |                   |      1 |    106 |    106 |00:00:00.01 |      37 |
|   3 |    NESTED LOOPS                 |                   |      1 |     27 |     27 |00:00:00.01 |      33 |
|   4 |     NESTED LOOPS                |                   |      1 |     23 |     23 |00:00:00.01 |      27 |
|   5 |      NESTED LOOPS               |                   |      1 |     25 |     25 |00:00:00.01 |      20 |
|   6 |       TABLE ACCESS FULL         | REGIONS           |      1 |      4 |      4 |00:00:00.01 |       7 |
|*  7 |       INDEX FAST FULL SCAN      | COUNTRY_C_ID_PK   |      4 |      6 |     25 |00:00:00.01 |      13 |
|   8 |      TABLE ACCESS BY INDEX ROWID| LOCATIONS         |     25 |      1 |     23 |00:00:00.01 |       7 |
|*  9 |       INDEX RANGE SCAN          | LOC_COUNTRY_IX    |     25 |      2 |     23 |00:00:00.01 |       5 |
|  10 |     TABLE ACCESS BY INDEX ROWID | DEPARTMENTS       |     23 |      1 |     27 |00:00:00.01 |       6 |
|* 11 |      INDEX RANGE SCAN           | DEPT_LOCATION_IX  |     23 |      4 |     27 |00:00:00.01 |       4 |
|* 12 |    INDEX RANGE SCAN             | EMP_DEPARTMENT_IX |     27 |     10 |    106 |00:00:00.01 |       4 |
|  13 |   TABLE ACCESS BY INDEX ROWID   | EMPLOYEES         |    106 |      4 |    106 |00:00:00.01 |       8 |
---------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   7 - filter("R"."REGION_ID"="C"."REGION_ID")
   9 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
  11 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
  12 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
```

<br>

Sort merge join
```sql
SELECT /*+ leading(r,c,l,d,e) use_merge(c) use_merge(l) use_merge(d) use_merge(e) */ e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
FROM employees e, departments d, locations l, countries c, regions r
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.country_id = c.country_id
AND r.region_id = c.region_id; 


>결과

----------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                          | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |  OMem |  1Mem | Used-Mem |
----------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                   |                 |      1 |        |    106 |00:00:00.01 |      21 |      6 |       |       |          |
|   1 |  MERGE JOIN                        |                 |      1 |    106 |    106 |00:00:00.01 |      21 |      6 |       |       |          |
|   2 |   SORT JOIN                        |                 |      1 |     27 |     27 |00:00:00.01 |      15 |      6 |  4096 |  4096 | 4096  (0)|
|   3 |    MERGE JOIN                      |                 |      1 |     27 |     27 |00:00:00.01 |      15 |      6 |       |       |          |
|   4 |     SORT JOIN                      |                 |      1 |     23 |     19 |00:00:00.01 |       9 |      1 |  4096 |  4096 | 4096  (0)|
|   5 |      MERGE JOIN                    |                 |      1 |     23 |     23 |00:00:00.01 |       9 |      1 |       |       |          |
|   6 |       SORT JOIN                    |                 |      1 |     25 |     24 |00:00:00.01 |       3 |      1 |  2048 |  2048 | 2048  (0)|
|   7 |        MERGE JOIN                  |                 |      1 |     25 |     25 |00:00:00.01 |       3 |      1 |       |       |          |
|   8 |         TABLE ACCESS BY INDEX ROWID| REGIONS         |      1 |      4 |      4 |00:00:00.01 |       2 |      1 |       |       |          |
|   9 |          INDEX FULL SCAN           | REG_ID_PK       |      1 |      4 |      4 |00:00:00.01 |       1 |      1 |       |       |          |
|* 10 |         SORT JOIN                  |                 |      4 |     25 |     25 |00:00:00.01 |       1 |      0 |  2048 |  2048 | 2048  (0)|
|  11 |          INDEX FULL SCAN           | COUNTRY_C_ID_PK |      1 |     25 |     25 |00:00:00.01 |       1 |      0 |       |       |          |
|* 12 |       SORT JOIN                    |                 |     24 |     23 |     23 |00:00:00.01 |       6 |      0 |  2048 |  2048 | 2048  (0)|
|  13 |        TABLE ACCESS FULL           | LOCATIONS       |      1 |     23 |     23 |00:00:00.01 |       6 |      0 |       |       |          |
|* 14 |     SORT JOIN                      |                 |     19 |     27 |     27 |00:00:00.01 |       6 |      5 |  2048 |  2048 | 2048  (0)|
|  15 |      TABLE ACCESS FULL             | DEPARTMENTS     |      1 |     27 |     27 |00:00:00.01 |       6 |      5 |       |       |          |
|* 16 |   SORT JOIN                        |                 |     27 |    107 |    106 |00:00:00.01 |       6 |      0 | 18432 | 18432 |16384  (0)|
|  17 |    TABLE ACCESS FULL               | EMPLOYEES       |      1 |    107 |    107 |00:00:00.01 |       6 |      0 |       |       |          |
----------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

  10 - access("R"."REGION_ID"="C"."REGION_ID")
       filter("R"."REGION_ID"="C"."REGION_ID")
  12 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
       filter("L"."COUNTRY_ID"="C"."COUNTRY_ID")
  14 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
       filter("D"."LOCATION_ID"="L"."LOCATION_ID")
  16 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
       filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")

--Arraysize를 늘리면 성능은 더 좋아진다
```

<br>

Hash join
```sql
SELECT /*+ leading(r,c,l,d,e) use_hash(c) use_hash(l) use_hash(d) use_hash(e) */ e.employee_id, e.last_name, e.salary, e.job_id, d.department_name, l.city, l.street_address, c.country_name, r.region_name
FROM employees e, departments d, locations l, countries c, regions r
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.country_id = c.country_id
AND r.region_id = c.region_id; 



>결과

------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |                 |      1 |        |    106 |00:00:00.01 |      32 |    |          |          |
|*  1 |  HASH JOIN            |                 |      1 |    106 |    106 |00:00:00.01 |      32 |   792K|   792K| 1244K (0)|
|*  2 |   HASH JOIN           |                 |      1 |     27 |     27 |00:00:00.01 |      19 |   832K|   832K| 1143K (0)|
|*  3 |    HASH JOIN          |                 |      1 |     23 |     23 |00:00:00.01 |      13 |   981K|   981K| 1233K (0)|
|*  4 |     HASH JOIN         |                 |      1 |     25 |     25 |00:00:00.01 |       7 |  1096K|  1096K|  739K (0)|
|   5 |      TABLE ACCESS FULL| REGIONS         |      1 |      4 |      4 |00:00:00.01 |       6 |    |          |          |
|   6 |      INDEX FULL SCAN  | COUNTRY_C_ID_PK |      1 |     25 |     25 |00:00:00.01 |       1 |    |          |          |
|   7 |     TABLE ACCESS FULL | LOCATIONS       |      1 |     23 |     23 |00:00:00.01 |       6 |    |          |          |
|   8 |    TABLE ACCESS FULL  | DEPARTMENTS     |      1 |     27 |     27 |00:00:00.01 |       6 |    |          |          |
|   9 |   TABLE ACCESS FULL   | EMPLOYEES       |      1 |    107 |    107 |00:00:00.01 |      13 |    |          |          |
------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   2 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
   3 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
   4 - access("R"."REGION_ID"="C"."REGION_ID")

--Arraysize를 늘리면 성능은 더 좋아진다
```

<br>

***

### 문제 128

<br>

```
```

<br>

```sql
```

<br>

***

### 문제 129

<br>

```
```

<br>

```sql
```

<br>

***